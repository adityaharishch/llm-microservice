# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class LiteLLM_BudgetTable(bases.BaseLiteLLM_BudgetTable):
    """Represents a LiteLLM_BudgetTable record"""

    budget_id: _str
    max_budget: Optional[_float] = None
    soft_budget: Optional[_float] = None
    max_parallel_requests: Optional[_int] = None
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    model_max_budget: Optional['fields.Json'] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    organization: Optional[List['models.LiteLLM_OrganizationTable']] = None
    keys: Optional[List['models.LiteLLM_VerificationToken']] = None
    end_users: Optional[List['models.LiteLLM_EndUserTable']] = None
    team_membership: Optional[List['models.LiteLLM_TeamMembership']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_BudgetTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_BudgetTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_BudgetTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_BudgetTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_BudgetTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_BudgetTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_BudgetTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_BudgetTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_BudgetTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_BudgetTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_BudgetTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_BudgetTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ProxyModelTable(bases.BaseLiteLLM_ProxyModelTable):
    """Represents a LiteLLM_ProxyModelTable record"""

    model_id: _str
    model_name: _str
    litellm_params: 'fields.Json'
    model_info: Optional['fields.Json'] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ProxyModelTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ProxyModelTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ProxyModelTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ProxyModelTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ProxyModelTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ProxyModelTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ProxyModelTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_ProxyModelTable" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ProxyModelTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ProxyModelTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_OrganizationTable(bases.BaseLiteLLM_OrganizationTable):
    """Represents a LiteLLM_OrganizationTable record"""

    organization_id: _str
    organization_alias: _str
    budget_id: _str
    metadata: 'fields.Json'
    models: List[_str]
    spend: _float
    model_spend: 'fields.Json'
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None
    teams: Optional[List['models.LiteLLM_TeamTable']] = None
    users: Optional[List['models.LiteLLM_UserTable']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('models', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_OrganizationTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_OrganizationTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_OrganizationTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_OrganizationTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_OrganizationTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_OrganizationTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_OrganizationTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_OrganizationTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_OrganizationTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_OrganizationTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_OrganizationTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_OrganizationTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ModelTable(bases.BaseLiteLLM_ModelTable):
    """Represents a LiteLLM_ModelTable record"""

    id: _int
    model_aliases: Optional['fields.Json'] = None
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    team: Optional['models.LiteLLM_TeamTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ModelTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ModelTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ModelTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ModelTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ModelTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ModelTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ModelTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_ModelTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_ModelTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_ModelTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ModelTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ModelTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_TeamTable(bases.BaseLiteLLM_TeamTable):
    """Represents a LiteLLM_TeamTable record"""

    team_id: _str
    team_alias: Optional[_str] = None
    organization_id: Optional[_str] = None
    admins: List[_str]
    members: List[_str]
    members_with_roles: 'fields.Json'
    metadata: 'fields.Json'
    max_budget: Optional[_float] = None
    spend: _float
    models: List[_str]
    max_parallel_requests: Optional[_int] = None
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    blocked: _bool
    created_at: datetime.datetime
    updated_at: datetime.datetime
    model_spend: 'fields.Json'
    model_max_budget: 'fields.Json'
    model_id: Optional[_int] = None
    litellm_organization_table: Optional['models.LiteLLM_OrganizationTable'] = None
    litellm_model_table: Optional['models.LiteLLM_ModelTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('admins', 'members', 'models', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_TeamTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_TeamTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_TeamTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_TeamTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_TeamTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_TeamTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_TeamTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_TeamTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_TeamTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_TeamTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_UserTable(bases.BaseLiteLLM_UserTable):
    """Represents a LiteLLM_UserTable record"""

    user_id: _str
    user_alias: Optional[_str] = None
    team_id: Optional[_str] = None
    organization_id: Optional[_str] = None
    password: Optional[_str] = None
    teams: List[_str]
    user_role: Optional[_str] = None
    max_budget: Optional[_float] = None
    spend: _float
    user_email: Optional[_str] = None
    models: List[_str]
    max_parallel_requests: Optional[_int] = None
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    allowed_cache_controls: List[_str]
    model_spend: 'fields.Json'
    model_max_budget: 'fields.Json'
    litellm_organization_table: Optional['models.LiteLLM_OrganizationTable'] = None
    invitations_created: Optional[List['models.LiteLLM_InvitationLink']] = None
    invitations_updated: Optional[List['models.LiteLLM_InvitationLink']] = None
    invitations_user: Optional[List['models.LiteLLM_InvitationLink']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('teams', 'models', 'allowed_cache_controls', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_UserTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_UserTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_UserTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_UserTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_UserTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_UserTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_UserTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_UserTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_UserTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_UserTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_VerificationToken(bases.BaseLiteLLM_VerificationToken):
    """Represents a LiteLLM_VerificationToken record"""

    token: _str
    key_name: Optional[_str] = None
    key_alias: Optional[_str] = None
    soft_budget_cooldown: _bool
    spend: _float
    expires: Optional[datetime.datetime] = None
    models: List[_str]
    aliases: 'fields.Json'
    config: 'fields.Json'
    user_id: Optional[_str] = None
    team_id: Optional[_str] = None
    permissions: 'fields.Json'
    max_parallel_requests: Optional[_int] = None
    metadata: 'fields.Json'
    tpm_limit: Optional[_int] = None
    rpm_limit: Optional[_int] = None
    max_budget: Optional[_float] = None
    budget_duration: Optional[_str] = None
    budget_reset_at: Optional[datetime.datetime] = None
    allowed_cache_controls: List[_str]
    model_spend: 'fields.Json'
    model_max_budget: 'fields.Json'
    budget_id: Optional[_str] = None
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('models', 'allowed_cache_controls', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_VerificationTokenKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_VerificationTokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_VerificationTokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_VerificationToken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_VerificationToken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_VerificationToken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_VerificationToken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_VerificationToken_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_VerificationToken_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_VerificationToken', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_VerificationToken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_VerificationToken',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_EndUserTable(bases.BaseLiteLLM_EndUserTable):
    """Represents a LiteLLM_EndUserTable record"""

    user_id: _str
    alias: Optional[_str] = None
    spend: _float
    allowed_model_region: Optional[_str] = None
    default_model: Optional[_str] = None
    budget_id: Optional[_str] = None
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None
    blocked: _bool

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_EndUserTableKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_EndUserTableRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_EndUserTableKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_EndUserTable_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_EndUserTable_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_EndUserTable_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_EndUserTable_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_EndUserTable_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_EndUserTable_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_EndUserTable', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_EndUserTable / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_EndUserTable',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_Config(bases.BaseLiteLLM_Config):
    """Represents a LiteLLM_Config record"""

    param_name: _str
    param_value: Optional['fields.Json'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ConfigKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ConfigRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ConfigKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_Config_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_Config_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_Config_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_Config_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_Config" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_Config / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_Config',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_SpendLogs(bases.BaseLiteLLM_SpendLogs):
    """Represents a LiteLLM_SpendLogs record"""

    request_id: _str
    call_type: _str
    api_key: _str
    spend: _float
    total_tokens: _int
    prompt_tokens: _int
    completion_tokens: _int
    startTime: datetime.datetime
    endTime: datetime.datetime
    completionStartTime: Optional[datetime.datetime] = None
    model: _str
    model_id: Optional[_str] = None
    model_group: Optional[_str] = None
    api_base: Optional[_str] = None
    user: Optional[_str] = None
    metadata: Optional['fields.Json'] = None
    cache_hit: Optional[_str] = None
    cache_key: Optional[_str] = None
    request_tags: Optional['fields.Json'] = None
    team_id: Optional[_str] = None
    end_user: Optional[_str] = None
    requester_ip_address: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_SpendLogsKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_SpendLogsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_SpendLogsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_SpendLogs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_SpendLogs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_SpendLogs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_SpendLogs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_SpendLogs" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_SpendLogs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_SpendLogs',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_ErrorLogs(bases.BaseLiteLLM_ErrorLogs):
    """Represents a LiteLLM_ErrorLogs record"""

    request_id: _str
    startTime: datetime.datetime
    endTime: datetime.datetime
    api_base: _str
    model_group: _str
    litellm_model_name: _str
    model_id: _str
    request_kwargs: 'fields.Json'
    exception_type: _str
    exception_string: _str
    status_code: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_ErrorLogsKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_ErrorLogsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_ErrorLogsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_ErrorLogs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_ErrorLogs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ErrorLogs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_ErrorLogs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_ErrorLogs" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_ErrorLogs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_ErrorLogs',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_UserNotifications(bases.BaseLiteLLM_UserNotifications):
    """Represents a LiteLLM_UserNotifications record"""

    request_id: _str
    user_id: _str
    models: List[_str]
    justification: _str
    status: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('models', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_UserNotificationsKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_UserNotificationsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_UserNotificationsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_UserNotifications_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_UserNotifications_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserNotifications_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_UserNotifications_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_UserNotifications" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_UserNotifications / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_UserNotifications',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_TeamMembership(bases.BaseLiteLLM_TeamMembership):
    """Represents a LiteLLM_TeamMembership record"""

    user_id: _str
    team_id: _str
    spend: _float
    budget_id: Optional[_str] = None
    litellm_budget_table: Optional['models.LiteLLM_BudgetTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_TeamMembershipKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_TeamMembershipRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_TeamMembershipKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_TeamMembership_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_TeamMembership_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamMembership_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_TeamMembership_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_TeamMembership_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_TeamMembership_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_TeamMembership', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_TeamMembership / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_TeamMembership',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_InvitationLink(bases.BaseLiteLLM_InvitationLink):
    """Represents a LiteLLM_InvitationLink record"""

    id: _str
    user_id: _str
    is_accepted: _bool
    accepted_at: Optional[datetime.datetime] = None
    expires_at: datetime.datetime
    created_at: datetime.datetime
    created_by: _str
    updated_at: datetime.datetime
    updated_by: _str
    liteLLM_user_table_user: Optional['models.LiteLLM_UserTable'] = None
    liteLLM_user_table_created: Optional['models.LiteLLM_UserTable'] = None
    liteLLM_user_table_updated: Optional['models.LiteLLM_UserTable'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_InvitationLinkKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_InvitationLinkRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_InvitationLinkKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_InvitationLink_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_InvitationLink_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_InvitationLink_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_InvitationLink_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LiteLLM_InvitationLink_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LiteLLM_InvitationLink_relational_fields:
                        raise errors.UnknownRelationalFieldError('LiteLLM_InvitationLink', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_InvitationLink / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_InvitationLink',
            }
        )
        _created_partial_types.add(name)


class LiteLLM_AuditLog(bases.BaseLiteLLM_AuditLog):
    """Represents a LiteLLM_AuditLog record"""

    id: _str
    updated_at: datetime.datetime
    changed_by: _str
    changed_by_api_key: _str
    action: _str
    table_name: _str
    object_id: _str
    before_value: Optional['fields.Json'] = None
    updated_values: Optional['fields.Json'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        exclude: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        required: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        optional: Optional[Iterable['types.LiteLLM_AuditLogKeys']] = None,
        relations: Optional[Mapping['types.LiteLLM_AuditLogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LiteLLM_AuditLogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LiteLLM_AuditLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LiteLLM_AuditLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_AuditLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LiteLLM_AuditLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "LiteLLM_AuditLog" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LiteLLM_AuditLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LiteLLM_AuditLog',
            }
        )
        _created_partial_types.add(name)



_LiteLLM_BudgetTable_relational_fields: Set[str] = {
        'organization',
        'keys',
        'end_users',
        'team_membership',
    }
_LiteLLM_BudgetTable_fields: Dict['types.LiteLLM_BudgetTableKeys', PartialModelField] = OrderedDict(
    [
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('soft_budget', {
            'name': 'soft_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_OrganizationTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('keys', {
            'name': 'keys',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_VerificationToken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('end_users', {
            'name': 'end_users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_EndUserTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('team_membership', {
            'name': 'team_membership',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_TeamMembership\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ProxyModelTable_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_ProxyModelTable_fields: Dict['types.LiteLLM_ProxyModelTableKeys', PartialModelField] = OrderedDict(
    [
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_name', {
            'name': 'model_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_params', {
            'name': 'litellm_params',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_info', {
            'name': 'model_info',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_OrganizationTable_relational_fields: Set[str] = {
        'litellm_budget_table',
        'teams',
        'users',
    }
_LiteLLM_OrganizationTable_fields: Dict['types.LiteLLM_OrganizationTableKeys', PartialModelField] = OrderedDict(
    [
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_alias', {
            'name': 'organization_alias',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_TeamTable\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_UserTable\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ModelTable_relational_fields: Set[str] = {
        'team',
    }
_LiteLLM_ModelTable_fields: Dict['types.LiteLLM_ModelTableKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_aliases', {
            'name': 'model_aliases',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team', {
            'name': 'team',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_TeamTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_TeamTable_relational_fields: Set[str] = {
        'litellm_organization_table',
        'litellm_model_table',
    }
_LiteLLM_TeamTable_fields: Dict['types.LiteLLM_TeamTableKeys', PartialModelField] = OrderedDict(
    [
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_alias', {
            'name': 'team_alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('admins', {
            'name': 'admins',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('members', {
            'name': 'members',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('members_with_roles', {
            'name': 'members_with_roles',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('blocked', {
            'name': 'blocked',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_organization_table', {
            'name': 'litellm_organization_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_OrganizationTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('litellm_model_table', {
            'name': 'litellm_model_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_ModelTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_UserTable_relational_fields: Set[str] = {
        'litellm_organization_table',
        'invitations_created',
        'invitations_updated',
        'invitations_user',
    }
_LiteLLM_UserTable_fields: Dict['types.LiteLLM_UserTableKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_alias', {
            'name': 'user_alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization_id', {
            'name': 'organization_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_role', {
            'name': 'user_role',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_email', {
            'name': 'user_email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('allowed_cache_controls', {
            'name': 'allowed_cache_controls',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_organization_table', {
            'name': 'litellm_organization_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_OrganizationTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitations_created', {
            'name': 'invitations_created',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_InvitationLink\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitations_updated', {
            'name': 'invitations_updated',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_InvitationLink\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitations_user', {
            'name': 'invitations_user',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LiteLLM_InvitationLink\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_VerificationToken_relational_fields: Set[str] = {
        'litellm_budget_table',
    }
_LiteLLM_VerificationToken_fields: Dict['types.LiteLLM_VerificationTokenKeys', PartialModelField] = OrderedDict(
    [
        ('token', {
            'name': 'token',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('key_name', {
            'name': 'key_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('key_alias', {
            'name': 'key_alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('soft_budget_cooldown', {
            'name': 'soft_budget_cooldown',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires', {
            'name': 'expires',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('aliases', {
            'name': 'aliases',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('config', {
            'name': 'config',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissions', {
            'name': 'permissions',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_parallel_requests', {
            'name': 'max_parallel_requests',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('tpm_limit', {
            'name': 'tpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rpm_limit', {
            'name': 'rpm_limit',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('max_budget', {
            'name': 'max_budget',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_duration', {
            'name': 'budget_duration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_reset_at', {
            'name': 'budget_reset_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('allowed_cache_controls', {
            'name': 'allowed_cache_controls',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_spend', {
            'name': 'model_spend',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_max_budget', {
            'name': 'model_max_budget',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_EndUserTable_relational_fields: Set[str] = {
        'litellm_budget_table',
    }
_LiteLLM_EndUserTable_fields: Dict['types.LiteLLM_EndUserTableKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('alias', {
            'name': 'alias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('allowed_model_region', {
            'name': 'allowed_model_region',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('default_model', {
            'name': 'default_model',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('blocked', {
            'name': 'blocked',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_Config_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_Config_fields: Dict['types.LiteLLM_ConfigKeys', PartialModelField] = OrderedDict(
    [
        ('param_name', {
            'name': 'param_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('param_value', {
            'name': 'param_value',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_SpendLogs_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_SpendLogs_fields: Dict['types.LiteLLM_SpendLogsKeys', PartialModelField] = OrderedDict(
    [
        ('request_id', {
            'name': 'request_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('call_type', {
            'name': 'call_type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_key', {
            'name': 'api_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('total_tokens', {
            'name': 'total_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('prompt_tokens', {
            'name': 'prompt_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('completion_tokens', {
            'name': 'completion_tokens',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('startTime', {
            'name': 'startTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endTime', {
            'name': 'endTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completionStartTime', {
            'name': 'completionStartTime',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('model', {
            'name': 'model',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_group', {
            'name': 'model_group',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_base', {
            'name': 'api_base',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_hit', {
            'name': 'cache_hit',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cache_key', {
            'name': 'cache_key',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('request_tags', {
            'name': 'request_tags',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('end_user', {
            'name': 'end_user',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requester_ip_address', {
            'name': 'requester_ip_address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_ErrorLogs_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_ErrorLogs_fields: Dict['types.LiteLLM_ErrorLogsKeys', PartialModelField] = OrderedDict(
    [
        ('request_id', {
            'name': 'request_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('startTime', {
            'name': 'startTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endTime', {
            'name': 'endTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('api_base', {
            'name': 'api_base',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_group', {
            'name': 'model_group',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_model_name', {
            'name': 'litellm_model_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('model_id', {
            'name': 'model_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('request_kwargs', {
            'name': 'request_kwargs',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('exception_type', {
            'name': 'exception_type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('exception_string', {
            'name': 'exception_string',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status_code', {
            'name': 'status_code',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_UserNotifications_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_UserNotifications_fields: Dict['types.LiteLLM_UserNotificationsKeys', PartialModelField] = OrderedDict(
    [
        ('request_id', {
            'name': 'request_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('models', {
            'name': 'models',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('justification', {
            'name': 'justification',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_LiteLLM_TeamMembership_relational_fields: Set[str] = {
        'litellm_budget_table',
    }
_LiteLLM_TeamMembership_fields: Dict['types.LiteLLM_TeamMembershipKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('team_id', {
            'name': 'team_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('spend', {
            'name': 'spend',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget_id', {
            'name': 'budget_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('litellm_budget_table', {
            'name': 'litellm_budget_table',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_BudgetTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_InvitationLink_relational_fields: Set[str] = {
        'liteLLM_user_table_user',
        'liteLLM_user_table_created',
        'liteLLM_user_table_updated',
    }
_LiteLLM_InvitationLink_fields: Dict['types.LiteLLM_InvitationLinkKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('is_accepted', {
            'name': 'is_accepted',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('accepted_at', {
            'name': 'accepted_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires_at', {
            'name': 'expires_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_by', {
            'name': 'created_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_by', {
            'name': 'updated_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('liteLLM_user_table_user', {
            'name': 'liteLLM_user_table_user',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_UserTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('liteLLM_user_table_created', {
            'name': 'liteLLM_user_table_created',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_UserTable',
            'is_relational': True,
            'documentation': None,
        }),
        ('liteLLM_user_table_updated', {
            'name': 'liteLLM_user_table_updated',
            'is_list': False,
            'optional': True,
            'type': 'models.LiteLLM_UserTable',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LiteLLM_AuditLog_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_LiteLLM_AuditLog_fields: Dict['types.LiteLLM_AuditLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('changed_by', {
            'name': 'changed_by',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('changed_by_api_key', {
            'name': 'changed_by_api_key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('action', {
            'name': 'action',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('table_name', {
            'name': 'table_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('object_id', {
            'name': 'object_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('before_value', {
            'name': 'before_value',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_values', {
            'name': 'updated_values',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(LiteLLM_BudgetTable)
model_rebuild(LiteLLM_ProxyModelTable)
model_rebuild(LiteLLM_OrganizationTable)
model_rebuild(LiteLLM_ModelTable)
model_rebuild(LiteLLM_TeamTable)
model_rebuild(LiteLLM_UserTable)
model_rebuild(LiteLLM_VerificationToken)
model_rebuild(LiteLLM_EndUserTable)
model_rebuild(LiteLLM_Config)
model_rebuild(LiteLLM_SpendLogs)
model_rebuild(LiteLLM_ErrorLogs)
model_rebuild(LiteLLM_UserNotifications)
model_rebuild(LiteLLM_TeamMembership)
model_rebuild(LiteLLM_InvitationLink)
model_rebuild(LiteLLM_AuditLog)
