# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class LiteLLM_BudgetTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_BudgetTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_BudgetTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_BudgetTable WHERE budget_id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_BudgetTable.prisma().query_first(
            'SELECT * FROM LiteLLM_BudgetTable WHERE max_budget = $1',
            377401575.66282,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_BudgetTableCreateInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_BudgetTable record.

        Parameters
        ----------
        data
            LiteLLM_BudgetTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The created LiteLLM_BudgetTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_BudgetTable record from just the required fields
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().create(
            data={
                # data to create a LiteLLM_BudgetTable record
                'created_by': 'bbehjachib',
                'updated_by': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_BudgetTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_BudgetTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_BudgetTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_BudgetTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_BudgetTable record
                    'created_by': 'dgiiaaijj',
                    'updated_by': 'bfaiacjjfc',
                },
                {
                    # data to create a LiteLLM_BudgetTable record
                    'created_by': 'eigcfgbif',
                    'updated_by': 'bagcfbhiig',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_BudgetTable record.

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The deleted LiteLLM_BudgetTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().delete(
            where={
                'budget_id': 'cghideieh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_BudgetTable record.

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The found LiteLLM_BudgetTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_unique(
            where={
                'budget_id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_BudgetTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The found LiteLLM_BudgetTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_unique_or_raise(
            where={
                'budget_id': 'idghgaicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
        order: Optional[Union[types.LiteLLM_BudgetTableOrderByInput, List[types.LiteLLM_BudgetTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_BudgetTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_BudgetTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_BudgetTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_BudgetTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model
        order
            Order the returned LiteLLM_BudgetTable records by any field
        distinct
            Filter LiteLLM_BudgetTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_BudgetTable]
            The list of all LiteLLM_BudgetTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_BudgetTable records
        litellm_budgettables = await LiteLLM_BudgetTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_BudgetTable records ordered by the soft_budget field
        litellm_budgettables = await LiteLLM_BudgetTable.prisma().find_many(
            take=5,
            order={
                'soft_budget': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
        order: Optional[Union[types.LiteLLM_BudgetTableOrderByInput, List[types.LiteLLM_BudgetTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_BudgetTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_BudgetTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model
        order
            Order the returned LiteLLM_BudgetTable records by any field
        distinct
            Filter LiteLLM_BudgetTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The first LiteLLM_BudgetTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_BudgetTable record ordered by the max_parallel_requests field
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_first(
            skip=1,
            order={
                'max_parallel_requests': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
        order: Optional[Union[types.LiteLLM_BudgetTableOrderByInput, List[types.LiteLLM_BudgetTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_BudgetTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_BudgetTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model
        order
            Order the returned LiteLLM_BudgetTable records by any field
        distinct
            Filter LiteLLM_BudgetTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The first LiteLLM_BudgetTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_BudgetTable record ordered by the tpm_limit field
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'tpm_limit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_BudgetTableUpdateInput,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_BudgetTable record.

        Parameters
        ----------
        data
            LiteLLM_BudgetTable record data specifying what to update
        where
            LiteLLM_BudgetTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The updated LiteLLM_BudgetTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().update(
            where={
                'budget_id': 'fjfddhigg',
            },
            data={
                # data to update the LiteLLM_BudgetTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_BudgetTableWhereUniqueInput,
        data: types.LiteLLM_BudgetTableUpsertInput,
        include: Optional[types.LiteLLM_BudgetTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_BudgetTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_BudgetTable model

        Returns
        -------
        prisma.models.LiteLLM_BudgetTable
            The created or updated LiteLLM_BudgetTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_budgettable = await LiteLLM_BudgetTable.prisma().upsert(
            where={
                'budget_id': 'hjaecfifb',
            },
            data={
                'create': {
                    'budget_id': 'hjaecfifb',
                    'created_by': 'eigcfgbif',
                    'updated_by': 'bagcfbhiig',
                },
                'update': {
                    'created_by': 'eigcfgbif',
                    'updated_by': 'bagcfbhiig',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_BudgetTableUpdateManyMutationInput,
        where: types.LiteLLM_BudgetTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_BudgetTable records

        Parameters
        ----------
        data
            LiteLLM_BudgetTable data to update the selected LiteLLM_BudgetTable records to
        where
            Filter to select the LiteLLM_BudgetTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_BudgetTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_BudgetTable records
        total = await LiteLLM_BudgetTable.prisma().update_many(
            data={
                'rpm_limit': 25342983456
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_BudgetTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_BudgetTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_BudgetTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_BudgetTable.prisma().count()

        # results: prisma.types.LiteLLM_BudgetTableCountAggregateOutput
        results = await LiteLLM_BudgetTable.prisma().count(
            select={
                '_all': True,
                'model_max_budget': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_BudgetTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_BudgetTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_BudgetTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_BudgetTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_BudgetTableCountAggregateOutput]:
        """Count the number of LiteLLM_BudgetTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_BudgetTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_BudgetTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_BudgetTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_BudgetTable.prisma().count()

        # results: prisma.types.LiteLLM_BudgetTableCountAggregateOutput
        results = await LiteLLM_BudgetTable.prisma().count(
            select={
                '_all': True,
                'budget_duration': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_BudgetTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_BudgetTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_BudgetTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_BudgetTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_BudgetTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_BudgetTable records
        total = await LiteLLM_BudgetTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_BudgetTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_BudgetTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_BudgetTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_BudgetTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_BudgetTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_BudgetTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_BudgetTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_BudgetTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_BudgetTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_BudgetTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_BudgetTableGroupByOutput']:
        """Group LiteLLM_BudgetTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_BudgetTable fields to group records by
        where
            LiteLLM_BudgetTable filter to select records
        take
            Limit the maximum number of LiteLLM_BudgetTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_BudgetTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_BudgetTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_BudgetTable records by budget_reset_at values
        # and count how many records are in each group
        results = await LiteLLM_BudgetTable.prisma().group_by(
            ['budget_reset_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ProxyModelTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ProxyModelTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ProxyModelTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ProxyModelTable WHERE model_id = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ProxyModelTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ProxyModelTable WHERE model_name = $1',
            'bgeecijdgg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ProxyModelTableCreateInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ProxyModelTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The created LiteLLM_ProxyModelTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ProxyModelTable record from just the required fields
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().create(
            data={
                # data to create a LiteLLM_ProxyModelTable record
                'model_name': 'bdiicjafbj',
                'litellm_params': Json({'bgehebiafc': True}),
                'created_by': 'bghffegacj',
                'updated_by': 'bhghchehcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ProxyModelTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ProxyModelTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ProxyModelTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ProxyModelTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ProxyModelTable record
                    'model_name': 'dcgchcbbf',
                    'litellm_params': Json({'bdedcabahc': True}),
                    'created_by': 'ghfhiafcb',
                    'updated_by': 'heejgedji',
                },
                {
                    # data to create a LiteLLM_ProxyModelTable record
                    'model_name': 'bjgjgibgbf',
                    'litellm_params': Json({'bbbgbhfjge': True}),
                    'created_by': 'igbehcbab',
                    'updated_by': 'bdadaadhag',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The deleted LiteLLM_ProxyModelTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().delete(
            where={
                'model_id': 'bgiggdidbf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The found LiteLLM_ProxyModelTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_unique(
            where={
                'model_id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ProxyModelTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The found LiteLLM_ProxyModelTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_unique_or_raise(
            where={
                'model_id': 'bigibebcib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ProxyModelTableOrderByInput, List[types.LiteLLM_ProxyModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ProxyModelTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ProxyModelTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ProxyModelTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ProxyModelTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model
        order
            Order the returned LiteLLM_ProxyModelTable records by any field
        distinct
            Filter LiteLLM_ProxyModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ProxyModelTable]
            The list of all LiteLLM_ProxyModelTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ProxyModelTable records
        litellm_proxymodeltables = await LiteLLM_ProxyModelTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ProxyModelTable records ordered by the litellm_params field
        litellm_proxymodeltables = await LiteLLM_ProxyModelTable.prisma().find_many(
            take=5,
            order={
                'litellm_params': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ProxyModelTableOrderByInput, List[types.LiteLLM_ProxyModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ProxyModelTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model
        order
            Order the returned LiteLLM_ProxyModelTable records by any field
        distinct
            Filter LiteLLM_ProxyModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The first LiteLLM_ProxyModelTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ProxyModelTable record ordered by the model_info field
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_first(
            skip=1,
            order={
                'model_info': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ProxyModelTableOrderByInput, List[types.LiteLLM_ProxyModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ProxyModelTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ProxyModelTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model
        order
            Order the returned LiteLLM_ProxyModelTable records by any field
        distinct
            Filter LiteLLM_ProxyModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The first LiteLLM_ProxyModelTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ProxyModelTable record ordered by the created_at field
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ProxyModelTableUpdateInput,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ProxyModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ProxyModelTable record data specifying what to update
        where
            LiteLLM_ProxyModelTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The updated LiteLLM_ProxyModelTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().update(
            where={
                'model_id': 'bigaiehgcc',
            },
            data={
                # data to update the LiteLLM_ProxyModelTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ProxyModelTableWhereUniqueInput,
        data: types.LiteLLM_ProxyModelTableUpsertInput,
        include: Optional[types.LiteLLM_ProxyModelTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ProxyModelTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ProxyModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ProxyModelTable
            The created or updated LiteLLM_ProxyModelTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_proxymodeltable = await LiteLLM_ProxyModelTable.prisma().upsert(
            where={
                'model_id': 'beeifcbebf',
            },
            data={
                'create': {
                    'model_id': 'beeifcbebf',
                    'model_name': 'bjgjgibgbf',
                    'litellm_params': Json({'bbbgbhfjge': True}),
                    'created_by': 'igbehcbab',
                    'updated_by': 'bdadaadhag',
                },
                'update': {
                    'model_name': 'bjgjgibgbf',
                    'litellm_params': Json({'bbbgbhfjge': True}),
                    'created_by': 'igbehcbab',
                    'updated_by': 'bdadaadhag',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ProxyModelTableUpdateManyMutationInput,
        where: types.LiteLLM_ProxyModelTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ProxyModelTable records

        Parameters
        ----------
        data
            LiteLLM_ProxyModelTable data to update the selected LiteLLM_ProxyModelTable records to
        where
            Filter to select the LiteLLM_ProxyModelTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ProxyModelTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ProxyModelTable records
        total = await LiteLLM_ProxyModelTable.prisma().update_many(
            data={
                'created_by': 'bgcigfahea'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ProxyModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ProxyModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ProxyModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
        results = await LiteLLM_ProxyModelTable.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ProxyModelTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ProxyModelTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ProxyModelTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ProxyModelTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ProxyModelTableCountAggregateOutput]:
        """Count the number of LiteLLM_ProxyModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ProxyModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ProxyModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ProxyModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ProxyModelTableCountAggregateOutput
        results = await LiteLLM_ProxyModelTable.prisma().count(
            select={
                '_all': True,
                'updated_by': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ProxyModelTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ProxyModelTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ProxyModelTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ProxyModelTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ProxyModelTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ProxyModelTable records
        total = await LiteLLM_ProxyModelTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ProxyModelTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ProxyModelTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ProxyModelTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ProxyModelTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ProxyModelTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ProxyModelTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ProxyModelTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ProxyModelTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ProxyModelTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ProxyModelTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ProxyModelTableGroupByOutput']:
        """Group LiteLLM_ProxyModelTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ProxyModelTable fields to group records by
        where
            LiteLLM_ProxyModelTable filter to select records
        take
            Limit the maximum number of LiteLLM_ProxyModelTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ProxyModelTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ProxyModelTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ProxyModelTable records by model_id values
        # and count how many records are in each group
        results = await LiteLLM_ProxyModelTable.prisma().group_by(
            ['model_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_OrganizationTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_OrganizationTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_OrganizationTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_OrganizationTable WHERE organization_id = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_OrganizationTable.prisma().query_first(
            'SELECT * FROM LiteLLM_OrganizationTable WHERE organization_alias = $1',
            'idfjadbcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_OrganizationTableCreateInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_OrganizationTable record.

        Parameters
        ----------
        data
            LiteLLM_OrganizationTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The created LiteLLM_OrganizationTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_OrganizationTable record from just the required fields
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().create(
            data={
                # data to create a LiteLLM_OrganizationTable record
                'organization_alias': 'hgdhbjhhj',
                'budget_id': 'ecjjjfbae',
                'created_by': 'bhhfibbigf',
                'updated_by': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_OrganizationTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_OrganizationTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_OrganizationTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_OrganizationTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_OrganizationTable record
                    'organization_alias': 'jjfeafhfj',
                    'budget_id': 'cbachdgfce',
                    'created_by': 'chbfcacbd',
                    'updated_by': 'efggddide',
                },
                {
                    # data to create a LiteLLM_OrganizationTable record
                    'organization_alias': 'caficfigfb',
                    'budget_id': 'bfidgijfjc',
                    'created_by': 'ihieecagf',
                    'updated_by': 'bghfciaafe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_OrganizationTable record.

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The deleted LiteLLM_OrganizationTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().delete(
            where={
                'organization_id': 'bgchfhgceh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_OrganizationTable record.

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The found LiteLLM_OrganizationTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_unique(
            where={
                'organization_id': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_OrganizationTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The found LiteLLM_OrganizationTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_unique_or_raise(
            where={
                'organization_id': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationTableOrderByInput, List[types.LiteLLM_OrganizationTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_OrganizationTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_OrganizationTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_OrganizationTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model
        order
            Order the returned LiteLLM_OrganizationTable records by any field
        distinct
            Filter LiteLLM_OrganizationTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_OrganizationTable]
            The list of all LiteLLM_OrganizationTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_OrganizationTable records
        litellm_organizationtables = await LiteLLM_OrganizationTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_OrganizationTable records ordered by the budget_id field
        litellm_organizationtables = await LiteLLM_OrganizationTable.prisma().find_many(
            take=5,
            order={
                'budget_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationTableOrderByInput, List[types.LiteLLM_OrganizationTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_OrganizationTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model
        order
            Order the returned LiteLLM_OrganizationTable records by any field
        distinct
            Filter LiteLLM_OrganizationTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The first LiteLLM_OrganizationTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_OrganizationTable record ordered by the metadata field
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_first(
            skip=1,
            order={
                'metadata': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
        order: Optional[Union[types.LiteLLM_OrganizationTableOrderByInput, List[types.LiteLLM_OrganizationTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_OrganizationTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_OrganizationTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model
        order
            Order the returned LiteLLM_OrganizationTable records by any field
        distinct
            Filter LiteLLM_OrganizationTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The first LiteLLM_OrganizationTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_OrganizationTable record ordered by the models field
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'models': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_OrganizationTableUpdateInput,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_OrganizationTable record.

        Parameters
        ----------
        data
            LiteLLM_OrganizationTable record data specifying what to update
        where
            LiteLLM_OrganizationTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The updated LiteLLM_OrganizationTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().update(
            where={
                'organization_id': 'gieegcbeg',
            },
            data={
                # data to update the LiteLLM_OrganizationTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_OrganizationTableWhereUniqueInput,
        data: types.LiteLLM_OrganizationTableUpsertInput,
        include: Optional[types.LiteLLM_OrganizationTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_OrganizationTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_OrganizationTable model

        Returns
        -------
        prisma.models.LiteLLM_OrganizationTable
            The created or updated LiteLLM_OrganizationTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_organizationtable = await LiteLLM_OrganizationTable.prisma().upsert(
            where={
                'organization_id': 'bgcffadich',
            },
            data={
                'create': {
                    'organization_id': 'bgcffadich',
                    'organization_alias': 'caficfigfb',
                    'budget_id': 'bfidgijfjc',
                    'created_by': 'ihieecagf',
                    'updated_by': 'bghfciaafe',
                },
                'update': {
                    'organization_alias': 'caficfigfb',
                    'budget_id': 'bfidgijfjc',
                    'created_by': 'ihieecagf',
                    'updated_by': 'bghfciaafe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_OrganizationTableUpdateManyMutationInput,
        where: types.LiteLLM_OrganizationTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_OrganizationTable records

        Parameters
        ----------
        data
            LiteLLM_OrganizationTable data to update the selected LiteLLM_OrganizationTable records to
        where
            Filter to select the LiteLLM_OrganizationTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_OrganizationTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_OrganizationTable records
        total = await LiteLLM_OrganizationTable.prisma().update_many(
            data={
                'spend': 521827728.126603
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_OrganizationTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_OrganizationTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_OrganizationTable.prisma().count()

        # results: prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
        results = await LiteLLM_OrganizationTable.prisma().count(
            select={
                '_all': True,
                'model_spend': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_OrganizationTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_OrganizationTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_OrganizationTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_OrganizationTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_OrganizationTableCountAggregateOutput]:
        """Count the number of LiteLLM_OrganizationTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_OrganizationTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_OrganizationTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_OrganizationTable.prisma().count()

        # results: prisma.types.LiteLLM_OrganizationTableCountAggregateOutput
        results = await LiteLLM_OrganizationTable.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_OrganizationTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_OrganizationTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_OrganizationTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_OrganizationTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_OrganizationTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_OrganizationTable records
        total = await LiteLLM_OrganizationTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_OrganizationTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_OrganizationTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_OrganizationTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_OrganizationTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_OrganizationTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_OrganizationTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_OrganizationTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_OrganizationTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_OrganizationTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_OrganizationTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_OrganizationTableGroupByOutput']:
        """Group LiteLLM_OrganizationTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_OrganizationTable fields to group records by
        where
            LiteLLM_OrganizationTable filter to select records
        take
            Limit the maximum number of LiteLLM_OrganizationTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_OrganizationTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_OrganizationTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_OrganizationTable records by created_by values
        # and count how many records are in each group
        results = await LiteLLM_OrganizationTable.prisma().group_by(
            ['created_by'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ModelTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ModelTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ModelTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_ModelTable WHERE id = $1',
            93253262,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ModelTable.prisma().query_first(
            'SELECT * FROM LiteLLM_ModelTable WHERE model_aliases = $1',
            Json({'cafdaehjid': True}),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ModelTableCreateInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ModelTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The created LiteLLM_ModelTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ModelTable record from just the required fields
        litellm_modeltable = await LiteLLM_ModelTable.prisma().create(
            data={
                # data to create a LiteLLM_ModelTable record
                'created_by': 'gifdddbia',
                'updated_by': 'bchehecef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ModelTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ModelTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ModelTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ModelTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ModelTable record
                    'created_by': 'jeijcbhfe',
                    'updated_by': 'bjgejjabff',
                },
                {
                    # data to create a LiteLLM_ModelTable record
                    'created_by': 'bcciijbibg',
                    'updated_by': 'cffcachfd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The deleted LiteLLM_ModelTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().delete(
            where={
                'id': 1223573862,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ModelTable record.

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The found LiteLLM_ModelTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_unique(
            where={
                'id': 541269159,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ModelTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The found LiteLLM_ModelTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_unique_or_raise(
            where={
                'id': 1064846676,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ModelTableOrderByInput, List[types.LiteLLM_ModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ModelTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ModelTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ModelTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ModelTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model
        order
            Order the returned LiteLLM_ModelTable records by any field
        distinct
            Filter LiteLLM_ModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ModelTable]
            The list of all LiteLLM_ModelTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ModelTable records
        litellm_modeltables = await LiteLLM_ModelTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ModelTable records ordered by the created_at field
        litellm_modeltables = await LiteLLM_ModelTable.prisma().find_many(
            take=5,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ModelTableOrderByInput, List[types.LiteLLM_ModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ModelTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ModelTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model
        order
            Order the returned LiteLLM_ModelTable records by any field
        distinct
            Filter LiteLLM_ModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The first LiteLLM_ModelTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ModelTable record ordered by the created_by field
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_first(
            skip=1,
            order={
                'created_by': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
        order: Optional[Union[types.LiteLLM_ModelTableOrderByInput, List[types.LiteLLM_ModelTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ModelTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ModelTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model
        order
            Order the returned LiteLLM_ModelTable records by any field
        distinct
            Filter LiteLLM_ModelTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The first LiteLLM_ModelTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ModelTable record ordered by the updated_at field
        litellm_modeltable = await LiteLLM_ModelTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'updated_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ModelTableUpdateInput,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ModelTable record.

        Parameters
        ----------
        data
            LiteLLM_ModelTable record data specifying what to update
        where
            LiteLLM_ModelTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The updated LiteLLM_ModelTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().update(
            where={
                'id': 508382461,
            },
            data={
                # data to update the LiteLLM_ModelTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ModelTableWhereUniqueInput,
        data: types.LiteLLM_ModelTableUpsertInput,
        include: Optional[types.LiteLLM_ModelTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ModelTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ModelTable model

        Returns
        -------
        prisma.models.LiteLLM_ModelTable
            The created or updated LiteLLM_ModelTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_modeltable = await LiteLLM_ModelTable.prisma().upsert(
            where={
                'id': 1024265714,
            },
            data={
                'create': {
                    'id': 1024265714,
                    'created_by': 'bcciijbibg',
                    'updated_by': 'cffcachfd',
                },
                'update': {
                    'created_by': 'bcciijbibg',
                    'updated_by': 'cffcachfd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ModelTableUpdateManyMutationInput,
        where: types.LiteLLM_ModelTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ModelTable records

        Parameters
        ----------
        data
            LiteLLM_ModelTable data to update the selected LiteLLM_ModelTable records to
        where
            Filter to select the LiteLLM_ModelTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_ModelTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ModelTable records
        total = await LiteLLM_ModelTable.prisma().update_many(
            data={
                'updated_by': 'ihcahiead'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ModelTableCountAggregateOutput
        results = await LiteLLM_ModelTable.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ModelTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_ModelTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ModelTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_ModelTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ModelTableCountAggregateOutput]:
        """Count the number of LiteLLM_ModelTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ModelTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ModelTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ModelTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ModelTable.prisma().count()

        # results: prisma.types.LiteLLM_ModelTableCountAggregateOutput
        results = await LiteLLM_ModelTable.prisma().count(
            select={
                '_all': True,
                'model_aliases': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ModelTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ModelTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ModelTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_ModelTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ModelTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ModelTable records
        total = await LiteLLM_ModelTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ModelTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ModelTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ModelTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ModelTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ModelTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ModelTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ModelTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ModelTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ModelTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ModelTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ModelTableGroupByOutput']:
        """Group LiteLLM_ModelTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ModelTable fields to group records by
        where
            LiteLLM_ModelTable filter to select records
        take
            Limit the maximum number of LiteLLM_ModelTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ModelTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_ModelTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ModelTable records by created_at values
        # and count how many records are in each group
        results = await LiteLLM_ModelTable.prisma().group_by(
            ['created_at'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_TeamTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_TeamTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_TeamTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_TeamTable WHERE team_id = $1',
            'biheheiajg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_TeamTable.prisma().query_first(
            'SELECT * FROM LiteLLM_TeamTable WHERE team_alias = $1',
            'jbgijghgb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_TeamTableCreateInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_TeamTable record.

        Parameters
        ----------
        data
            LiteLLM_TeamTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The created LiteLLM_TeamTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_TeamTable record from just the required fields
        litellm_teamtable = await LiteLLM_TeamTable.prisma().create(
            data={
                # data to create a LiteLLM_TeamTable record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_TeamTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_TeamTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_TeamTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_TeamTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_TeamTable record
                },
                {
                    # data to create a LiteLLM_TeamTable record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_TeamTable record.

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The deleted LiteLLM_TeamTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().delete(
            where={
                'team_id': 'hgjcghfbi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_TeamTable record.

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The found LiteLLM_TeamTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_unique(
            where={
                'team_id': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_TeamTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The found LiteLLM_TeamTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_unique_or_raise(
            where={
                'team_id': 'jchciaee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamTableOrderByInput, List[types.LiteLLM_TeamTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_TeamTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_TeamTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_TeamTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model
        order
            Order the returned LiteLLM_TeamTable records by any field
        distinct
            Filter LiteLLM_TeamTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_TeamTable]
            The list of all LiteLLM_TeamTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_TeamTable records
        litellm_teamtables = await LiteLLM_TeamTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_TeamTable records ordered by the organization_id field
        litellm_teamtables = await LiteLLM_TeamTable.prisma().find_many(
            take=5,
            order={
                'organization_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamTableOrderByInput, List[types.LiteLLM_TeamTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_TeamTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model
        order
            Order the returned LiteLLM_TeamTable records by any field
        distinct
            Filter LiteLLM_TeamTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The first LiteLLM_TeamTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamTable record ordered by the admins field
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_first(
            skip=1,
            order={
                'admins': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamTableOrderByInput, List[types.LiteLLM_TeamTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_TeamTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model
        order
            Order the returned LiteLLM_TeamTable records by any field
        distinct
            Filter LiteLLM_TeamTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The first LiteLLM_TeamTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamTable record ordered by the members field
        litellm_teamtable = await LiteLLM_TeamTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'members': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_TeamTableUpdateInput,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_TeamTable record.

        Parameters
        ----------
        data
            LiteLLM_TeamTable record data specifying what to update
        where
            LiteLLM_TeamTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The updated LiteLLM_TeamTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().update(
            where={
                'team_id': 'deeificjd',
            },
            data={
                # data to update the LiteLLM_TeamTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_TeamTableWhereUniqueInput,
        data: types.LiteLLM_TeamTableUpsertInput,
        include: Optional[types.LiteLLM_TeamTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_TeamTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamTable model

        Returns
        -------
        prisma.models.LiteLLM_TeamTable
            The created or updated LiteLLM_TeamTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teamtable = await LiteLLM_TeamTable.prisma().upsert(
            where={
                'team_id': 'bbcbhebbda',
            },
            data={
                'create': {
                    'team_id': 'bbcbhebbda',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_TeamTableUpdateManyMutationInput,
        where: types.LiteLLM_TeamTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_TeamTable records

        Parameters
        ----------
        data
            LiteLLM_TeamTable data to update the selected LiteLLM_TeamTable records to
        where
            Filter to select the LiteLLM_TeamTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_TeamTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_TeamTable records
        total = await LiteLLM_TeamTable.prisma().update_many(
            data={
                'members_with_roles': Json({'bejfijgcfb': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_TeamTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamTable.prisma().count()

        # results: prisma.types.LiteLLM_TeamTableCountAggregateOutput
        results = await LiteLLM_TeamTable.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_TeamTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_TeamTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_TeamTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_TeamTableCountAggregateOutput]:
        """Count the number of LiteLLM_TeamTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamTable.prisma().count()

        # results: prisma.types.LiteLLM_TeamTableCountAggregateOutput
        results = await LiteLLM_TeamTable.prisma().count(
            select={
                '_all': True,
                'max_budget': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_TeamTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_TeamTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_TeamTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_TeamTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_TeamTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_TeamTable records
        total = await LiteLLM_TeamTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_TeamTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_TeamTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_TeamTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_TeamTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_TeamTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_TeamTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_TeamTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_TeamTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_TeamTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_TeamTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_TeamTableGroupByOutput']:
        """Group LiteLLM_TeamTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_TeamTable fields to group records by
        where
            LiteLLM_TeamTable filter to select records
        take
            Limit the maximum number of LiteLLM_TeamTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_TeamTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_TeamTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_TeamTable records by spend values
        # and count how many records are in each group
        results = await LiteLLM_TeamTable.prisma().group_by(
            ['spend'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_UserTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_UserTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_UserTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_UserTable WHERE user_id = $1',
            'caifcbgii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_UserTable.prisma().query_first(
            'SELECT * FROM LiteLLM_UserTable WHERE user_alias = $1',
            'igaibbfgj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_UserTableCreateInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_UserTable record.

        Parameters
        ----------
        data
            LiteLLM_UserTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The created LiteLLM_UserTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_UserTable record from just the required fields
        litellm_usertable = await LiteLLM_UserTable.prisma().create(
            data={
                # data to create a LiteLLM_UserTable record
                'user_id': 'bggajdcbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_UserTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_UserTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_UserTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_UserTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_UserTable record
                    'user_id': 'fcfhgbjed',
                },
                {
                    # data to create a LiteLLM_UserTable record
                    'user_id': 'hdgcajhjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_UserTable record.

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The deleted LiteLLM_UserTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().delete(
            where={
                'user_id': 'ejdjahicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_UserTable record.

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The found LiteLLM_UserTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().find_unique(
            where={
                'user_id': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_UserTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The found LiteLLM_UserTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().find_unique_or_raise(
            where={
                'user_id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_UserTableOrderByInput, List[types.LiteLLM_UserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_UserTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_UserTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_UserTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model
        order
            Order the returned LiteLLM_UserTable records by any field
        distinct
            Filter LiteLLM_UserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_UserTable]
            The list of all LiteLLM_UserTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_UserTable records
        litellm_usertables = await LiteLLM_UserTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_UserTable records ordered by the team_id field
        litellm_usertables = await LiteLLM_UserTable.prisma().find_many(
            take=5,
            order={
                'team_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_UserTableOrderByInput, List[types.LiteLLM_UserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_UserTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model
        order
            Order the returned LiteLLM_UserTable records by any field
        distinct
            Filter LiteLLM_UserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The first LiteLLM_UserTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserTable record ordered by the organization_id field
        litellm_usertable = await LiteLLM_UserTable.prisma().find_first(
            skip=1,
            order={
                'organization_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_UserTableOrderByInput, List[types.LiteLLM_UserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_UserTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model
        order
            Order the returned LiteLLM_UserTable records by any field
        distinct
            Filter LiteLLM_UserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The first LiteLLM_UserTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserTable record ordered by the password field
        litellm_usertable = await LiteLLM_UserTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_UserTableUpdateInput,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_UserTable record.

        Parameters
        ----------
        data
            LiteLLM_UserTable record data specifying what to update
        where
            LiteLLM_UserTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The updated LiteLLM_UserTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().update(
            where={
                'user_id': 'bjafcgbffc',
            },
            data={
                # data to update the LiteLLM_UserTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_UserTableWhereUniqueInput,
        data: types.LiteLLM_UserTableUpsertInput,
        include: Optional[types.LiteLLM_UserTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_UserTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserTable model

        Returns
        -------
        prisma.models.LiteLLM_UserTable
            The created or updated LiteLLM_UserTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usertable = await LiteLLM_UserTable.prisma().upsert(
            where={
                'user_id': 'hihegjif',
            },
            data={
                'create': {
                    'user_id': 'hihegjif',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_UserTableUpdateManyMutationInput,
        where: types.LiteLLM_UserTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_UserTable records

        Parameters
        ----------
        data
            LiteLLM_UserTable data to update the selected LiteLLM_UserTable records to
        where
            Filter to select the LiteLLM_UserTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_UserTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_UserTable records
        total = await LiteLLM_UserTable.prisma().update_many(
            data={
                'teams': ['bdjidcidac']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_UserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserTable.prisma().count()

        # results: prisma.types.LiteLLM_UserTableCountAggregateOutput
        results = await LiteLLM_UserTable.prisma().count(
            select={
                '_all': True,
                'user_role': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_UserTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_UserTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_UserTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_UserTableCountAggregateOutput]:
        """Count the number of LiteLLM_UserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserTable.prisma().count()

        # results: prisma.types.LiteLLM_UserTableCountAggregateOutput
        results = await LiteLLM_UserTable.prisma().count(
            select={
                '_all': True,
                'max_budget': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_UserTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_UserTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_UserTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_UserTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_UserTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_UserTable records
        total = await LiteLLM_UserTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_UserTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_UserTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_UserTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_UserTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_UserTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_UserTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_UserTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_UserTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_UserTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_UserTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_UserTableGroupByOutput']:
        """Group LiteLLM_UserTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_UserTable fields to group records by
        where
            LiteLLM_UserTable filter to select records
        take
            Limit the maximum number of LiteLLM_UserTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_UserTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_UserTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_UserTable records by spend values
        # and count how many records are in each group
        results = await LiteLLM_UserTable.prisma().group_by(
            ['spend'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_VerificationTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_VerificationToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_VerificationToken.prisma().query_raw(
            'SELECT * FROM LiteLLM_VerificationToken WHERE token = $1',
            'ifgaaagff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_VerificationToken.prisma().query_first(
            'SELECT * FROM LiteLLM_VerificationToken WHERE key_name = $1',
            'befcddgjce',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_VerificationTokenCreateInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_VerificationToken record.

        Parameters
        ----------
        data
            LiteLLM_VerificationToken record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The created LiteLLM_VerificationToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_VerificationToken record from just the required fields
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().create(
            data={
                # data to create a LiteLLM_VerificationToken record
                'token': 'bfhdbjjgfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_VerificationTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_VerificationToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_VerificationToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_VerificationToken.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_VerificationToken record
                    'token': 'cabdjadaji',
                },
                {
                    # data to create a LiteLLM_VerificationToken record
                    'token': 'faajgfadf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_VerificationToken record.

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The deleted LiteLLM_VerificationToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().delete(
            where={
                'token': 'biaagcedjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_VerificationToken record.

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The found LiteLLM_VerificationToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_unique(
            where={
                'token': 'cahhaghecf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_VerificationToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The found LiteLLM_VerificationToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_unique_or_raise(
            where={
                'token': 'bghcbbcidi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
        order: Optional[Union[types.LiteLLM_VerificationTokenOrderByInput, List[types.LiteLLM_VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_VerificationTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_VerificationToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_VerificationToken records returned
        skip
            Ignore the first N results
        where
            LiteLLM_VerificationToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model
        order
            Order the returned LiteLLM_VerificationToken records by any field
        distinct
            Filter LiteLLM_VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_VerificationToken]
            The list of all LiteLLM_VerificationToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_VerificationToken records
        litellm_verificationtokens = await LiteLLM_VerificationToken.prisma().find_many(take=10)

        # find the first 5 LiteLLM_VerificationToken records ordered by the key_alias field
        litellm_verificationtokens = await LiteLLM_VerificationToken.prisma().find_many(
            take=5,
            order={
                'key_alias': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
        order: Optional[Union[types.LiteLLM_VerificationTokenOrderByInput, List[types.LiteLLM_VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_VerificationTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_VerificationToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model
        order
            Order the returned LiteLLM_VerificationToken records by any field
        distinct
            Filter LiteLLM_VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The first LiteLLM_VerificationToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_VerificationToken record ordered by the soft_budget_cooldown field
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_first(
            skip=1,
            order={
                'soft_budget_cooldown': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
        order: Optional[Union[types.LiteLLM_VerificationTokenOrderByInput, List[types.LiteLLM_VerificationTokenOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_VerificationTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_VerificationToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model
        order
            Order the returned LiteLLM_VerificationToken records by any field
        distinct
            Filter LiteLLM_VerificationToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The first LiteLLM_VerificationToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_VerificationToken record ordered by the spend field
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_VerificationTokenUpdateInput,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_VerificationToken record.

        Parameters
        ----------
        data
            LiteLLM_VerificationToken record data specifying what to update
        where
            LiteLLM_VerificationToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The updated LiteLLM_VerificationToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().update(
            where={
                'token': 'jcgghhgdj',
            },
            data={
                # data to update the LiteLLM_VerificationToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_VerificationTokenWhereUniqueInput,
        data: types.LiteLLM_VerificationTokenUpsertInput,
        include: Optional[types.LiteLLM_VerificationTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_VerificationToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_VerificationToken model

        Returns
        -------
        prisma.models.LiteLLM_VerificationToken
            The created or updated LiteLLM_VerificationToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_verificationtoken = await LiteLLM_VerificationToken.prisma().upsert(
            where={
                'token': 'beehgcebbg',
            },
            data={
                'create': {
                    'token': 'beehgcebbg',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_VerificationTokenUpdateManyMutationInput,
        where: types.LiteLLM_VerificationTokenWhereInput,
    ) -> int:
        """Update multiple LiteLLM_VerificationToken records

        Parameters
        ----------
        data
            LiteLLM_VerificationToken data to update the selected LiteLLM_VerificationToken records to
        where
            Filter to select the LiteLLM_VerificationToken records to update

        Returns
        -------
        int
            The total number of LiteLLM_VerificationToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_VerificationToken records
        total = await LiteLLM_VerificationToken.prisma().update_many(
            data={
                'expires': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_VerificationToken.prisma().count()

        # results: prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
        results = await LiteLLM_VerificationToken.prisma().count(
            select={
                '_all': True,
                'models': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_VerificationTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
    ) -> types.LiteLLM_VerificationTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_VerificationTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None,
        cursor: Optional[types.LiteLLM_VerificationTokenWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_VerificationTokenCountAggregateOutput]:
        """Count the number of LiteLLM_VerificationToken records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_VerificationToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_VerificationToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_VerificationToken.prisma().count()

        # results: prisma.types.LiteLLM_VerificationTokenCountAggregateOutput
        results = await LiteLLM_VerificationToken.prisma().count(
            select={
                '_all': True,
                'aliases': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_VerificationTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_VerificationTokenWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_VerificationToken records.

        Parameters
        ----------
        where
            Optional LiteLLM_VerificationToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_VerificationToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_VerificationToken records
        total = await LiteLLM_VerificationToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_VerificationTokenScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_VerificationTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_VerificationTokenAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_VerificationTokenSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_VerificationTokenMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_VerificationTokenMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_VerificationTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_VerificationTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_VerificationTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_VerificationTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_VerificationTokenGroupByOutput']:
        """Group LiteLLM_VerificationToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_VerificationToken fields to group records by
        where
            LiteLLM_VerificationToken filter to select records
        take
            Limit the maximum number of LiteLLM_VerificationToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_VerificationTokenGroupByOutput]
            A list of dictionaries representing the LiteLLM_VerificationToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_VerificationToken records by config values
        # and count how many records are in each group
        results = await LiteLLM_VerificationToken.prisma().group_by(
            ['config'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_EndUserTableActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_EndUserTable]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_EndUserTable.prisma().query_raw(
            'SELECT * FROM LiteLLM_EndUserTable WHERE user_id = $1',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_EndUserTable.prisma().query_first(
            'SELECT * FROM LiteLLM_EndUserTable WHERE alias = $1',
            'deajegcfi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_EndUserTableCreateInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_EndUserTable record.

        Parameters
        ----------
        data
            LiteLLM_EndUserTable record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The created LiteLLM_EndUserTable record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_EndUserTable record from just the required fields
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().create(
            data={
                # data to create a LiteLLM_EndUserTable record
                'user_id': 'gabahhhjf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_EndUserTableCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_EndUserTable records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_EndUserTable record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_EndUserTable.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_EndUserTable record
                    'user_id': 'cjagadcjg',
                },
                {
                    # data to create a LiteLLM_EndUserTable record
                    'user_id': 'bifficggej',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_EndUserTable record.

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The deleted LiteLLM_EndUserTable record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().delete(
            where={
                'user_id': 'bgbbaajbic',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_EndUserTable record.

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The found LiteLLM_EndUserTable record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_unique(
            where={
                'user_id': 'eegghdhjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_EndUserTable record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The found LiteLLM_EndUserTable record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_unique_or_raise(
            where={
                'user_id': 'daafgidjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_EndUserTableOrderByInput, List[types.LiteLLM_EndUserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_EndUserTableScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_EndUserTable records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_EndUserTable records returned
        skip
            Ignore the first N results
        where
            LiteLLM_EndUserTable filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model
        order
            Order the returned LiteLLM_EndUserTable records by any field
        distinct
            Filter LiteLLM_EndUserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_EndUserTable]
            The list of all LiteLLM_EndUserTable records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_EndUserTable records
        litellm_endusertables = await LiteLLM_EndUserTable.prisma().find_many(take=10)

        # find the first 5 LiteLLM_EndUserTable records ordered by the spend field
        litellm_endusertables = await LiteLLM_EndUserTable.prisma().find_many(
            take=5,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_EndUserTableOrderByInput, List[types.LiteLLM_EndUserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_EndUserTableScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_EndUserTable record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model
        order
            Order the returned LiteLLM_EndUserTable records by any field
        distinct
            Filter LiteLLM_EndUserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The first LiteLLM_EndUserTable record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_EndUserTable record ordered by the allowed_model_region field
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_first(
            skip=1,
            order={
                'allowed_model_region': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
        order: Optional[Union[types.LiteLLM_EndUserTableOrderByInput, List[types.LiteLLM_EndUserTableOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_EndUserTableScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_EndUserTable record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model
        order
            Order the returned LiteLLM_EndUserTable records by any field
        distinct
            Filter LiteLLM_EndUserTable records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The first LiteLLM_EndUserTable record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_EndUserTable record ordered by the default_model field
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().find_first_or_raise(
            skip=1,
            order={
                'default_model': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_EndUserTableUpdateInput,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_EndUserTable record.

        Parameters
        ----------
        data
            LiteLLM_EndUserTable record data specifying what to update
        where
            LiteLLM_EndUserTable filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The updated LiteLLM_EndUserTable record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().update(
            where={
                'user_id': 'gdcgcgagj',
            },
            data={
                # data to update the LiteLLM_EndUserTable record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_EndUserTableWhereUniqueInput,
        data: types.LiteLLM_EndUserTableUpsertInput,
        include: Optional[types.LiteLLM_EndUserTableInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_EndUserTable filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_EndUserTable model

        Returns
        -------
        prisma.models.LiteLLM_EndUserTable
            The created or updated LiteLLM_EndUserTable record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_endusertable = await LiteLLM_EndUserTable.prisma().upsert(
            where={
                'user_id': 'bhceabbgja',
            },
            data={
                'create': {
                    'user_id': 'bhceabbgja',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_EndUserTableUpdateManyMutationInput,
        where: types.LiteLLM_EndUserTableWhereInput,
    ) -> int:
        """Update multiple LiteLLM_EndUserTable records

        Parameters
        ----------
        data
            LiteLLM_EndUserTable data to update the selected LiteLLM_EndUserTable records to
        where
            Filter to select the LiteLLM_EndUserTable records to update

        Returns
        -------
        int
            The total number of LiteLLM_EndUserTable records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_EndUserTable records
        total = await LiteLLM_EndUserTable.prisma().update_many(
            data={
                'budget_id': 'ehabfhegh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_EndUserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_EndUserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_EndUserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_EndUserTable.prisma().count()

        # results: prisma.types.LiteLLM_EndUserTableCountAggregateOutput
        results = await LiteLLM_EndUserTable.prisma().count(
            select={
                '_all': True,
                'blocked': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_EndUserTableCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
    ) -> types.LiteLLM_EndUserTableCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_EndUserTableCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None,
        cursor: Optional[types.LiteLLM_EndUserTableWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_EndUserTableCountAggregateOutput]:
        """Count the number of LiteLLM_EndUserTable records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_EndUserTable fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_EndUserTable filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_EndUserTableCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_EndUserTable.prisma().count()

        # results: prisma.types.LiteLLM_EndUserTableCountAggregateOutput
        results = await LiteLLM_EndUserTable.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_EndUserTableCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_EndUserTableWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_EndUserTable records.

        Parameters
        ----------
        where
            Optional LiteLLM_EndUserTable filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_EndUserTable records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_EndUserTable records
        total = await LiteLLM_EndUserTable.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_EndUserTableScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_EndUserTableWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_EndUserTableAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_EndUserTableSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_EndUserTableMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_EndUserTableMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_EndUserTableScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_EndUserTableCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_EndUserTableScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_EndUserTableScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_EndUserTableGroupByOutput']:
        """Group LiteLLM_EndUserTable records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_EndUserTable fields to group records by
        where
            LiteLLM_EndUserTable filter to select records
        take
            Limit the maximum number of LiteLLM_EndUserTable records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_EndUserTableGroupByOutput]
            A list of dictionaries representing the LiteLLM_EndUserTable record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_EndUserTable records by alias values
        # and count how many records are in each group
        results = await LiteLLM_EndUserTable.prisma().group_by(
            ['alias'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ConfigActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_Config]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_Config.prisma().query_raw(
            'SELECT * FROM LiteLLM_Config WHERE param_name = $1',
            'bcajcajjbc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_Config
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_Config.prisma().query_first(
            'SELECT * FROM LiteLLM_Config WHERE param_value = $1',
            Json({'bfdgheeegf': True}),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ConfigCreateInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_Config record.

        Parameters
        ----------
        data
            LiteLLM_Config record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The created LiteLLM_Config record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_Config record from just the required fields
        litellm_config = await LiteLLM_Config.prisma().create(
            data={
                # data to create a LiteLLM_Config record
                'param_name': 'ececbijji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ConfigCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_Config records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_Config record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_Config.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_Config record
                    'param_name': 'cbcfgdcdhf',
                },
                {
                    # data to create a LiteLLM_Config record
                    'param_name': 'fdgjfbhia',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_Config record.

        Parameters
        ----------
        where
            LiteLLM_Config filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The deleted LiteLLM_Config record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().delete(
            where={
                'param_name': 'jcehcdchh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_Config record.

        Parameters
        ----------
        where
            LiteLLM_Config filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The found LiteLLM_Config record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().find_unique(
            where={
                'param_name': 'bgcbjdhjcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_Config record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_Config filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The found LiteLLM_Config record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().find_unique_or_raise(
            where={
                'param_name': 'bieiidcabj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
        order: Optional[Union[types.LiteLLM_ConfigOrderByInput, List[types.LiteLLM_ConfigOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ConfigScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_Config records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_Config records returned
        skip
            Ignore the first N results
        where
            LiteLLM_Config filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model
        order
            Order the returned LiteLLM_Config records by any field
        distinct
            Filter LiteLLM_Config records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_Config]
            The list of all LiteLLM_Config records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_Config records
        litellm_configs = await LiteLLM_Config.prisma().find_many(take=10)

        # find the first 5 LiteLLM_Config records ordered by the param_name field
        litellm_configs = await LiteLLM_Config.prisma().find_many(
            take=5,
            order={
                'param_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
        order: Optional[Union[types.LiteLLM_ConfigOrderByInput, List[types.LiteLLM_ConfigOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ConfigScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_Config record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model
        order
            Order the returned LiteLLM_Config records by any field
        distinct
            Filter LiteLLM_Config records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_Config
            The first LiteLLM_Config record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_Config record ordered by the param_value field
        litellm_config = await LiteLLM_Config.prisma().find_first(
            skip=1,
            order={
                'param_value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
        order: Optional[Union[types.LiteLLM_ConfigOrderByInput, List[types.LiteLLM_ConfigOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ConfigScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_Config record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model
        order
            Order the returned LiteLLM_Config records by any field
        distinct
            Filter LiteLLM_Config records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_Config
            The first LiteLLM_Config record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_Config record ordered by the param_name field
        litellm_config = await LiteLLM_Config.prisma().find_first_or_raise(
            skip=1,
            order={
                'param_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ConfigUpdateInput,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_Config record.

        Parameters
        ----------
        data
            LiteLLM_Config record data specifying what to update
        where
            LiteLLM_Config filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The updated LiteLLM_Config record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().update(
            where={
                'param_name': 'bjcbfcieaa',
            },
            data={
                # data to update the LiteLLM_Config record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ConfigWhereUniqueInput,
        data: types.LiteLLM_ConfigUpsertInput,
        include: Optional[types.LiteLLM_ConfigInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_Config filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_Config model

        Returns
        -------
        prisma.models.LiteLLM_Config
            The created or updated LiteLLM_Config record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_config = await LiteLLM_Config.prisma().upsert(
            where={
                'param_name': 'cbaaechiej',
            },
            data={
                'create': {
                    'param_name': 'cbaaechiej',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ConfigUpdateManyMutationInput,
        where: types.LiteLLM_ConfigWhereInput,
    ) -> int:
        """Update multiple LiteLLM_Config records

        Parameters
        ----------
        data
            LiteLLM_Config data to update the selected LiteLLM_Config records to
        where
            Filter to select the LiteLLM_Config records to update

        Returns
        -------
        int
            The total number of LiteLLM_Config records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_Config records
        total = await LiteLLM_Config.prisma().update_many(
            data={
                'param_value': Json({'iejbeaaeg': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_Config records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_Config fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_Config.prisma().count()

        # results: prisma.types.LiteLLM_ConfigCountAggregateOutput
        results = await LiteLLM_Config.prisma().count(
            select={
                '_all': True,
                'param_name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ConfigCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
    ) -> types.LiteLLM_ConfigCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ConfigCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None,
        cursor: Optional[types.LiteLLM_ConfigWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ConfigCountAggregateOutput]:
        """Count the number of LiteLLM_Config records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_Config fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_Config filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ConfigCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_Config.prisma().count()

        # results: prisma.types.LiteLLM_ConfigCountAggregateOutput
        results = await LiteLLM_Config.prisma().count(
            select={
                '_all': True,
                'param_value': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ConfigCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ConfigWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_Config records.

        Parameters
        ----------
        where
            Optional LiteLLM_Config filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_Config records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_Config records
        total = await LiteLLM_Config.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ConfigScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ConfigWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ConfigAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ConfigSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ConfigMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ConfigMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ConfigScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ConfigCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ConfigScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ConfigScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ConfigGroupByOutput']:
        """Group LiteLLM_Config records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_Config fields to group records by
        where
            LiteLLM_Config filter to select records
        take
            Limit the maximum number of LiteLLM_Config records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ConfigGroupByOutput]
            A list of dictionaries representing the LiteLLM_Config record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_Config records by param_name values
        # and count how many records are in each group
        results = await LiteLLM_Config.prisma().group_by(
            ['param_name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_SpendLogsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_SpendLogs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_SpendLogs.prisma().query_raw(
            'SELECT * FROM LiteLLM_SpendLogs WHERE request_id = $1',
            'jcibfcbhf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_SpendLogs.prisma().query_first(
            'SELECT * FROM LiteLLM_SpendLogs WHERE call_type = $1',
            'chdadcaga',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_SpendLogsCreateInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_SpendLogs record.

        Parameters
        ----------
        data
            LiteLLM_SpendLogs record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The created LiteLLM_SpendLogs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_SpendLogs record from just the required fields
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().create(
            data={
                # data to create a LiteLLM_SpendLogs record
                'request_id': 'jicieifbh',
                'call_type': 'fbahdheji',
                'startTime': datetime.datetime.utcnow(),
                'endTime': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_SpendLogsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_SpendLogs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_SpendLogs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_SpendLogs.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_SpendLogs record
                    'request_id': 'cbbheiicgh',
                    'call_type': 'beabjeejdg',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                {
                    # data to create a LiteLLM_SpendLogs record
                    'request_id': 'bcjhgahffd',
                    'call_type': 'fbjeiiffa',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_SpendLogs record.

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The deleted LiteLLM_SpendLogs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().delete(
            where={
                'request_id': 'jhgidcgbf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_SpendLogs record.

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The found LiteLLM_SpendLogs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_unique(
            where={
                'request_id': 'bgjgecfejc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_SpendLogs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The found LiteLLM_SpendLogs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_unique_or_raise(
            where={
                'request_id': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_SpendLogsOrderByInput, List[types.LiteLLM_SpendLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_SpendLogsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_SpendLogs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_SpendLogs records returned
        skip
            Ignore the first N results
        where
            LiteLLM_SpendLogs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model
        order
            Order the returned LiteLLM_SpendLogs records by any field
        distinct
            Filter LiteLLM_SpendLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_SpendLogs]
            The list of all LiteLLM_SpendLogs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_SpendLogs records
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_many(take=10)

        # find the first 5 LiteLLM_SpendLogs records ordered by the api_key field
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_many(
            take=5,
            order={
                'api_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_SpendLogsOrderByInput, List[types.LiteLLM_SpendLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_SpendLogsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_SpendLogs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model
        order
            Order the returned LiteLLM_SpendLogs records by any field
        distinct
            Filter LiteLLM_SpendLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The first LiteLLM_SpendLogs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_SpendLogs record ordered by the spend field
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_first(
            skip=1,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_SpendLogsOrderByInput, List[types.LiteLLM_SpendLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_SpendLogsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_SpendLogs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model
        order
            Order the returned LiteLLM_SpendLogs records by any field
        distinct
            Filter LiteLLM_SpendLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The first LiteLLM_SpendLogs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_SpendLogs record ordered by the total_tokens field
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().find_first_or_raise(
            skip=1,
            order={
                'total_tokens': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_SpendLogsUpdateInput,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_SpendLogs record.

        Parameters
        ----------
        data
            LiteLLM_SpendLogs record data specifying what to update
        where
            LiteLLM_SpendLogs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The updated LiteLLM_SpendLogs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().update(
            where={
                'request_id': 'bacdaibgfa',
            },
            data={
                # data to update the LiteLLM_SpendLogs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_SpendLogsWhereUniqueInput,
        data: types.LiteLLM_SpendLogsUpsertInput,
        include: Optional[types.LiteLLM_SpendLogsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_SpendLogs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_SpendLogs model

        Returns
        -------
        prisma.models.LiteLLM_SpendLogs
            The created or updated LiteLLM_SpendLogs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_spendlogs = await LiteLLM_SpendLogs.prisma().upsert(
            where={
                'request_id': 'dchgibach',
            },
            data={
                'create': {
                    'request_id': 'dchgibach',
                    'call_type': 'fbjeiiffa',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                'update': {
                    'call_type': 'fbjeiiffa',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_SpendLogsUpdateManyMutationInput,
        where: types.LiteLLM_SpendLogsWhereInput,
    ) -> int:
        """Update multiple LiteLLM_SpendLogs records

        Parameters
        ----------
        data
            LiteLLM_SpendLogs data to update the selected LiteLLM_SpendLogs records to
        where
            Filter to select the LiteLLM_SpendLogs records to update

        Returns
        -------
        int
            The total number of LiteLLM_SpendLogs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_SpendLogs records
        total = await LiteLLM_SpendLogs.prisma().update_many(
            data={
                'prompt_tokens': 527748992
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_SpendLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_SpendLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_SpendLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_SpendLogs.prisma().count()

        # results: prisma.types.LiteLLM_SpendLogsCountAggregateOutput
        results = await LiteLLM_SpendLogs.prisma().count(
            select={
                '_all': True,
                'completion_tokens': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_SpendLogsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
    ) -> types.LiteLLM_SpendLogsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_SpendLogsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_SpendLogsWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_SpendLogsCountAggregateOutput]:
        """Count the number of LiteLLM_SpendLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_SpendLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_SpendLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_SpendLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_SpendLogs.prisma().count()

        # results: prisma.types.LiteLLM_SpendLogsCountAggregateOutput
        results = await LiteLLM_SpendLogs.prisma().count(
            select={
                '_all': True,
                'startTime': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_SpendLogsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_SpendLogsWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_SpendLogs records.

        Parameters
        ----------
        where
            Optional LiteLLM_SpendLogs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_SpendLogs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_SpendLogs records
        total = await LiteLLM_SpendLogs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_SpendLogsScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_SpendLogsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_SpendLogsAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_SpendLogsSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_SpendLogsMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_SpendLogsMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_SpendLogsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_SpendLogsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_SpendLogsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_SpendLogsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_SpendLogsGroupByOutput']:
        """Group LiteLLM_SpendLogs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_SpendLogs fields to group records by
        where
            LiteLLM_SpendLogs filter to select records
        take
            Limit the maximum number of LiteLLM_SpendLogs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_SpendLogsGroupByOutput]
            A list of dictionaries representing the LiteLLM_SpendLogs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_SpendLogs records by endTime values
        # and count how many records are in each group
        results = await LiteLLM_SpendLogs.prisma().group_by(
            ['endTime'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_ErrorLogsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_ErrorLogs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_ErrorLogs.prisma().query_raw(
            'SELECT * FROM LiteLLM_ErrorLogs WHERE request_id = $1',
            'cacjdfhejh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_ErrorLogs.prisma().query_first(
            'SELECT * FROM LiteLLM_ErrorLogs WHERE startTime = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_ErrorLogsCreateInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_ErrorLogs record.

        Parameters
        ----------
        data
            LiteLLM_ErrorLogs record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The created LiteLLM_ErrorLogs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_ErrorLogs record from just the required fields
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().create(
            data={
                # data to create a LiteLLM_ErrorLogs record
                'startTime': datetime.datetime.utcnow(),
                'endTime': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_ErrorLogsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_ErrorLogs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_ErrorLogs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_ErrorLogs.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_ErrorLogs record
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                {
                    # data to create a LiteLLM_ErrorLogs record
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_ErrorLogs record.

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The deleted LiteLLM_ErrorLogs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().delete(
            where={
                'request_id': 'bdbifjhbbi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_ErrorLogs record.

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The found LiteLLM_ErrorLogs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_unique(
            where={
                'request_id': 'cbccbbcdfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_ErrorLogs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The found LiteLLM_ErrorLogs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_unique_or_raise(
            where={
                'request_id': 'bacejedaca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_ErrorLogsOrderByInput, List[types.LiteLLM_ErrorLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ErrorLogsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_ErrorLogs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_ErrorLogs records returned
        skip
            Ignore the first N results
        where
            LiteLLM_ErrorLogs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model
        order
            Order the returned LiteLLM_ErrorLogs records by any field
        distinct
            Filter LiteLLM_ErrorLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_ErrorLogs]
            The list of all LiteLLM_ErrorLogs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_ErrorLogs records
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_many(take=10)

        # find the first 5 LiteLLM_ErrorLogs records ordered by the endTime field
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_many(
            take=5,
            order={
                'endTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_ErrorLogsOrderByInput, List[types.LiteLLM_ErrorLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ErrorLogsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_ErrorLogs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model
        order
            Order the returned LiteLLM_ErrorLogs records by any field
        distinct
            Filter LiteLLM_ErrorLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The first LiteLLM_ErrorLogs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ErrorLogs record ordered by the api_base field
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_first(
            skip=1,
            order={
                'api_base': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
        order: Optional[Union[types.LiteLLM_ErrorLogsOrderByInput, List[types.LiteLLM_ErrorLogsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_ErrorLogsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_ErrorLogs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model
        order
            Order the returned LiteLLM_ErrorLogs records by any field
        distinct
            Filter LiteLLM_ErrorLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The first LiteLLM_ErrorLogs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_ErrorLogs record ordered by the model_group field
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().find_first_or_raise(
            skip=1,
            order={
                'model_group': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_ErrorLogsUpdateInput,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_ErrorLogs record.

        Parameters
        ----------
        data
            LiteLLM_ErrorLogs record data specifying what to update
        where
            LiteLLM_ErrorLogs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The updated LiteLLM_ErrorLogs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().update(
            where={
                'request_id': 'bhbhdahfaj',
            },
            data={
                # data to update the LiteLLM_ErrorLogs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_ErrorLogsWhereUniqueInput,
        data: types.LiteLLM_ErrorLogsUpsertInput,
        include: Optional[types.LiteLLM_ErrorLogsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_ErrorLogs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_ErrorLogs model

        Returns
        -------
        prisma.models.LiteLLM_ErrorLogs
            The created or updated LiteLLM_ErrorLogs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_errorlogs = await LiteLLM_ErrorLogs.prisma().upsert(
            where={
                'request_id': 'bfjibceaec',
            },
            data={
                'create': {
                    'request_id': 'bfjibceaec',
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
                'update': {
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_ErrorLogsUpdateManyMutationInput,
        where: types.LiteLLM_ErrorLogsWhereInput,
    ) -> int:
        """Update multiple LiteLLM_ErrorLogs records

        Parameters
        ----------
        data
            LiteLLM_ErrorLogs data to update the selected LiteLLM_ErrorLogs records to
        where
            Filter to select the LiteLLM_ErrorLogs records to update

        Returns
        -------
        int
            The total number of LiteLLM_ErrorLogs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_ErrorLogs records
        total = await LiteLLM_ErrorLogs.prisma().update_many(
            data={
                'litellm_model_name': 'ibhgcdbgd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_ErrorLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ErrorLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ErrorLogs.prisma().count()

        # results: prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
        results = await LiteLLM_ErrorLogs.prisma().count(
            select={
                '_all': True,
                'model_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_ErrorLogsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
    ) -> types.LiteLLM_ErrorLogsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_ErrorLogsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None,
        cursor: Optional[types.LiteLLM_ErrorLogsWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_ErrorLogsCountAggregateOutput]:
        """Count the number of LiteLLM_ErrorLogs records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_ErrorLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_ErrorLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_ErrorLogs.prisma().count()

        # results: prisma.types.LiteLLM_ErrorLogsCountAggregateOutput
        results = await LiteLLM_ErrorLogs.prisma().count(
            select={
                '_all': True,
                'request_kwargs': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_ErrorLogsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_ErrorLogsWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_ErrorLogs records.

        Parameters
        ----------
        where
            Optional LiteLLM_ErrorLogs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_ErrorLogs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_ErrorLogs records
        total = await LiteLLM_ErrorLogs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_ErrorLogsScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_ErrorLogsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_ErrorLogsAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_ErrorLogsSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_ErrorLogsMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_ErrorLogsMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_ErrorLogsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_ErrorLogsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_ErrorLogsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_ErrorLogsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_ErrorLogsGroupByOutput']:
        """Group LiteLLM_ErrorLogs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_ErrorLogs fields to group records by
        where
            LiteLLM_ErrorLogs filter to select records
        take
            Limit the maximum number of LiteLLM_ErrorLogs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_ErrorLogsGroupByOutput]
            A list of dictionaries representing the LiteLLM_ErrorLogs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_ErrorLogs records by exception_type values
        # and count how many records are in each group
        results = await LiteLLM_ErrorLogs.prisma().group_by(
            ['exception_type'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_UserNotificationsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_UserNotifications]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_UserNotifications.prisma().query_raw(
            'SELECT * FROM LiteLLM_UserNotifications WHERE request_id = $1',
            'badaffhddg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_UserNotifications.prisma().query_first(
            'SELECT * FROM LiteLLM_UserNotifications WHERE user_id = $1',
            'bbdbfcfihd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_UserNotificationsCreateInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_UserNotifications record.

        Parameters
        ----------
        data
            LiteLLM_UserNotifications record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The created LiteLLM_UserNotifications record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_UserNotifications record from just the required fields
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().create(
            data={
                # data to create a LiteLLM_UserNotifications record
                'request_id': 'cbagggbji',
                'user_id': 'bchgafhjed',
                'justification': 'heffgjdei',
                'status': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_UserNotificationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_UserNotifications records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_UserNotifications record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_UserNotifications.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_UserNotifications record
                    'request_id': 'bgheaejbcc',
                    'user_id': 'bfcgifeged',
                    'justification': 'jfiahhbae',
                    'status': 'bfbdafajcb',
                },
                {
                    # data to create a LiteLLM_UserNotifications record
                    'request_id': 'caeghehde',
                    'user_id': 'caghgfbggd',
                    'justification': 'bbidjbbjaa',
                    'status': 'bfijhaejdd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_UserNotifications record.

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The deleted LiteLLM_UserNotifications record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().delete(
            where={
                'request_id': 'bcedehfiji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_UserNotifications record.

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The found LiteLLM_UserNotifications record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_unique(
            where={
                'request_id': 'bdgjicijhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_UserNotifications record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The found LiteLLM_UserNotifications record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_unique_or_raise(
            where={
                'request_id': 'bghifjdeia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
        order: Optional[Union[types.LiteLLM_UserNotificationsOrderByInput, List[types.LiteLLM_UserNotificationsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserNotificationsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_UserNotifications records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_UserNotifications records returned
        skip
            Ignore the first N results
        where
            LiteLLM_UserNotifications filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model
        order
            Order the returned LiteLLM_UserNotifications records by any field
        distinct
            Filter LiteLLM_UserNotifications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_UserNotifications]
            The list of all LiteLLM_UserNotifications records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_UserNotifications records
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_many(take=10)

        # find the first 5 LiteLLM_UserNotifications records ordered by the models field
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_many(
            take=5,
            order={
                'models': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
        order: Optional[Union[types.LiteLLM_UserNotificationsOrderByInput, List[types.LiteLLM_UserNotificationsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserNotificationsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_UserNotifications record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model
        order
            Order the returned LiteLLM_UserNotifications records by any field
        distinct
            Filter LiteLLM_UserNotifications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The first LiteLLM_UserNotifications record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserNotifications record ordered by the justification field
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_first(
            skip=1,
            order={
                'justification': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
        order: Optional[Union[types.LiteLLM_UserNotificationsOrderByInput, List[types.LiteLLM_UserNotificationsOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_UserNotificationsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_UserNotifications record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model
        order
            Order the returned LiteLLM_UserNotifications records by any field
        distinct
            Filter LiteLLM_UserNotifications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The first LiteLLM_UserNotifications record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_UserNotifications record ordered by the status field
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_UserNotificationsUpdateInput,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_UserNotifications record.

        Parameters
        ----------
        data
            LiteLLM_UserNotifications record data specifying what to update
        where
            LiteLLM_UserNotifications filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The updated LiteLLM_UserNotifications record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().update(
            where={
                'request_id': 'eadfcbbcb',
            },
            data={
                # data to update the LiteLLM_UserNotifications record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_UserNotificationsWhereUniqueInput,
        data: types.LiteLLM_UserNotificationsUpsertInput,
        include: Optional[types.LiteLLM_UserNotificationsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_UserNotifications filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_UserNotifications model

        Returns
        -------
        prisma.models.LiteLLM_UserNotifications
            The created or updated LiteLLM_UserNotifications record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_usernotifications = await LiteLLM_UserNotifications.prisma().upsert(
            where={
                'request_id': 'geihgahba',
            },
            data={
                'create': {
                    'request_id': 'geihgahba',
                    'user_id': 'caghgfbggd',
                    'justification': 'bbidjbbjaa',
                    'status': 'bfijhaejdd',
                },
                'update': {
                    'user_id': 'caghgfbggd',
                    'justification': 'bbidjbbjaa',
                    'status': 'bfijhaejdd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_UserNotificationsUpdateManyMutationInput,
        where: types.LiteLLM_UserNotificationsWhereInput,
    ) -> int:
        """Update multiple LiteLLM_UserNotifications records

        Parameters
        ----------
        data
            LiteLLM_UserNotifications data to update the selected LiteLLM_UserNotifications records to
        where
            Filter to select the LiteLLM_UserNotifications records to update

        Returns
        -------
        int
            The total number of LiteLLM_UserNotifications records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_UserNotifications records
        total = await LiteLLM_UserNotifications.prisma().update_many(
            data={
                'request_id': 'gahdcdhbj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_UserNotifications records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserNotifications fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserNotifications.prisma().count()

        # results: prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
        results = await LiteLLM_UserNotifications.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_UserNotificationsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
    ) -> types.LiteLLM_UserNotificationsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_UserNotificationsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None,
        cursor: Optional[types.LiteLLM_UserNotificationsWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_UserNotificationsCountAggregateOutput]:
        """Count the number of LiteLLM_UserNotifications records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_UserNotifications fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_UserNotifications filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_UserNotifications.prisma().count()

        # results: prisma.types.LiteLLM_UserNotificationsCountAggregateOutput
        results = await LiteLLM_UserNotifications.prisma().count(
            select={
                '_all': True,
                'models': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_UserNotificationsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_UserNotificationsWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_UserNotifications records.

        Parameters
        ----------
        where
            Optional LiteLLM_UserNotifications filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_UserNotifications records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_UserNotifications records
        total = await LiteLLM_UserNotifications.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_UserNotificationsScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_UserNotificationsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_UserNotificationsAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_UserNotificationsSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_UserNotificationsMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_UserNotificationsMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_UserNotificationsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_UserNotificationsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_UserNotificationsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_UserNotificationsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_UserNotificationsGroupByOutput']:
        """Group LiteLLM_UserNotifications records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_UserNotifications fields to group records by
        where
            LiteLLM_UserNotifications filter to select records
        take
            Limit the maximum number of LiteLLM_UserNotifications records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_UserNotificationsGroupByOutput]
            A list of dictionaries representing the LiteLLM_UserNotifications record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_UserNotifications records by justification values
        # and count how many records are in each group
        results = await LiteLLM_UserNotifications.prisma().group_by(
            ['justification'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_TeamMembershipActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_TeamMembership]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_TeamMembership.prisma().query_raw(
            'SELECT * FROM LiteLLM_TeamMembership WHERE user_id = $1',
            'begiijahea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_TeamMembership.prisma().query_first(
            'SELECT * FROM LiteLLM_TeamMembership WHERE team_id = $1',
            'gcjadjaaf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_TeamMembershipCreateInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_TeamMembership record.

        Parameters
        ----------
        data
            LiteLLM_TeamMembership record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The created LiteLLM_TeamMembership record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_TeamMembership record from just the required fields
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().create(
            data={
                # data to create a LiteLLM_TeamMembership record
                'user_id': 'bcbebgiaic',
                'team_id': 'ijigbdcbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_TeamMembershipCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_TeamMembership records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_TeamMembership record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_TeamMembership.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_TeamMembership record
                    'user_id': 'gfidhicai',
                    'team_id': 'jfegcaafh',
                },
                {
                    # data to create a LiteLLM_TeamMembership record
                    'user_id': 'bcbeiajjfa',
                    'team_id': 'baehicaajf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_TeamMembership record.

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The deleted LiteLLM_TeamMembership record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().delete(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_TeamMembership record.

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The found LiteLLM_TeamMembership record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_unique(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_TeamMembership record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The found LiteLLM_TeamMembership record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_unique_or_raise(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamMembershipOrderByInput, List[types.LiteLLM_TeamMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamMembershipScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_TeamMembership records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_TeamMembership records returned
        skip
            Ignore the first N results
        where
            LiteLLM_TeamMembership filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model
        order
            Order the returned LiteLLM_TeamMembership records by any field
        distinct
            Filter LiteLLM_TeamMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_TeamMembership]
            The list of all LiteLLM_TeamMembership records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_TeamMembership records
        litellm_teammemberships = await LiteLLM_TeamMembership.prisma().find_many(take=10)

        # find the first 5 LiteLLM_TeamMembership records ordered by the spend field
        litellm_teammemberships = await LiteLLM_TeamMembership.prisma().find_many(
            take=5,
            order={
                'spend': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamMembershipOrderByInput, List[types.LiteLLM_TeamMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamMembershipScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_TeamMembership record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model
        order
            Order the returned LiteLLM_TeamMembership records by any field
        distinct
            Filter LiteLLM_TeamMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The first LiteLLM_TeamMembership record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamMembership record ordered by the budget_id field
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_first(
            skip=1,
            order={
                'budget_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
        order: Optional[Union[types.LiteLLM_TeamMembershipOrderByInput, List[types.LiteLLM_TeamMembershipOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_TeamMembershipScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_TeamMembership record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model
        order
            Order the returned LiteLLM_TeamMembership records by any field
        distinct
            Filter LiteLLM_TeamMembership records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The first LiteLLM_TeamMembership record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_TeamMembership record ordered by the user_id field
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_TeamMembershipUpdateInput,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_TeamMembership record.

        Parameters
        ----------
        data
            LiteLLM_TeamMembership record data specifying what to update
        where
            LiteLLM_TeamMembership filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The updated LiteLLM_TeamMembership record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().update(
            where={
                # LiteLLM_TeamMembership where unique filter

            },
            data={
                # data to update the LiteLLM_TeamMembership record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_TeamMembershipWhereUniqueInput,
        data: types.LiteLLM_TeamMembershipUpsertInput,
        include: Optional[types.LiteLLM_TeamMembershipInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_TeamMembership filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_TeamMembership model

        Returns
        -------
        prisma.models.LiteLLM_TeamMembership
            The created or updated LiteLLM_TeamMembership record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_teammembership = await LiteLLM_TeamMembership.prisma().upsert(
            where={
                # LiteLLM_TeamMembership where unique filter
            },
            data={
                'create': {
                    # LiteLLM_TeamMembership data to be set if the record does not exist
                },
                'update': {
                    # LiteLLM_TeamMembership data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_TeamMembershipUpdateManyMutationInput,
        where: types.LiteLLM_TeamMembershipWhereInput,
    ) -> int:
        """Update multiple LiteLLM_TeamMembership records

        Parameters
        ----------
        data
            LiteLLM_TeamMembership data to update the selected LiteLLM_TeamMembership records to
        where
            Filter to select the LiteLLM_TeamMembership records to update

        Returns
        -------
        int
            The total number of LiteLLM_TeamMembership records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_TeamMembership records
        total = await LiteLLM_TeamMembership.prisma().update_many(
            data={
                'team_id': 'bdachdeiga'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_TeamMembership records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamMembership fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamMembership.prisma().count()

        # results: prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
        results = await LiteLLM_TeamMembership.prisma().count(
            select={
                '_all': True,
                'spend': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_TeamMembershipCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
    ) -> types.LiteLLM_TeamMembershipCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_TeamMembershipCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None,
        cursor: Optional[types.LiteLLM_TeamMembershipWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_TeamMembershipCountAggregateOutput]:
        """Count the number of LiteLLM_TeamMembership records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_TeamMembership fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_TeamMembership filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_TeamMembership.prisma().count()

        # results: prisma.types.LiteLLM_TeamMembershipCountAggregateOutput
        results = await LiteLLM_TeamMembership.prisma().count(
            select={
                '_all': True,
                'budget_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_TeamMembershipCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_TeamMembershipWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_TeamMembership records.

        Parameters
        ----------
        where
            Optional LiteLLM_TeamMembership filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_TeamMembership records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_TeamMembership records
        total = await LiteLLM_TeamMembership.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_TeamMembershipScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_TeamMembershipWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_TeamMembershipAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_TeamMembershipSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_TeamMembershipMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_TeamMembershipMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_TeamMembershipScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_TeamMembershipCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_TeamMembershipScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_TeamMembershipScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_TeamMembershipGroupByOutput']:
        """Group LiteLLM_TeamMembership records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_TeamMembership fields to group records by
        where
            LiteLLM_TeamMembership filter to select records
        take
            Limit the maximum number of LiteLLM_TeamMembership records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_TeamMembershipGroupByOutput]
            A list of dictionaries representing the LiteLLM_TeamMembership record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_TeamMembership records by user_id values
        # and count how many records are in each group
        results = await LiteLLM_TeamMembership.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_InvitationLinkActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_InvitationLink]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_InvitationLink.prisma().query_raw(
            'SELECT * FROM LiteLLM_InvitationLink WHERE id = $1',
            'ijdafccef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_InvitationLink.prisma().query_first(
            'SELECT * FROM LiteLLM_InvitationLink WHERE user_id = $1',
            'ciaaiddag',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_InvitationLinkCreateInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_InvitationLink record.

        Parameters
        ----------
        data
            LiteLLM_InvitationLink record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The created LiteLLM_InvitationLink record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_InvitationLink record from just the required fields
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().create(
            data={
                # data to create a LiteLLM_InvitationLink record
                'user_id': 'fejggijff',
                'expires_at': datetime.datetime.utcnow(),
                'created_at': datetime.datetime.utcnow(),
                'created_by': 'hghjaaai',
                'updated_at': datetime.datetime.utcnow(),
                'updated_by': 'cajicjjdef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_InvitationLinkCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_InvitationLink records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_InvitationLink record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_InvitationLink.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_InvitationLink record
                    'user_id': 'cefjaadec',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'ibbigdigd',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'bdiiiabbii',
                },
                {
                    # data to create a LiteLLM_InvitationLink record
                    'user_id': 'hfcfhhadh',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'bbihggdcji',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'hgjgibdgd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_InvitationLink record.

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The deleted LiteLLM_InvitationLink record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().delete(
            where={
                'id': 'bcbecjfice',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_InvitationLink record.

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The found LiteLLM_InvitationLink record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_unique(
            where={
                'id': 'bacbebhjjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_InvitationLink record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The found LiteLLM_InvitationLink record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_unique_or_raise(
            where={
                'id': 'dfbfaddhe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
        order: Optional[Union[types.LiteLLM_InvitationLinkOrderByInput, List[types.LiteLLM_InvitationLinkOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_InvitationLinkScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_InvitationLink records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_InvitationLink records returned
        skip
            Ignore the first N results
        where
            LiteLLM_InvitationLink filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model
        order
            Order the returned LiteLLM_InvitationLink records by any field
        distinct
            Filter LiteLLM_InvitationLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_InvitationLink]
            The list of all LiteLLM_InvitationLink records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_InvitationLink records
        litellm_invitationlinks = await LiteLLM_InvitationLink.prisma().find_many(take=10)

        # find the first 5 LiteLLM_InvitationLink records ordered by the is_accepted field
        litellm_invitationlinks = await LiteLLM_InvitationLink.prisma().find_many(
            take=5,
            order={
                'is_accepted': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
        order: Optional[Union[types.LiteLLM_InvitationLinkOrderByInput, List[types.LiteLLM_InvitationLinkOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_InvitationLinkScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_InvitationLink record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model
        order
            Order the returned LiteLLM_InvitationLink records by any field
        distinct
            Filter LiteLLM_InvitationLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The first LiteLLM_InvitationLink record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_InvitationLink record ordered by the accepted_at field
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_first(
            skip=1,
            order={
                'accepted_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
        order: Optional[Union[types.LiteLLM_InvitationLinkOrderByInput, List[types.LiteLLM_InvitationLinkOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_InvitationLinkScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_InvitationLink record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model
        order
            Order the returned LiteLLM_InvitationLink records by any field
        distinct
            Filter LiteLLM_InvitationLink records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The first LiteLLM_InvitationLink record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_InvitationLink record ordered by the expires_at field
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().find_first_or_raise(
            skip=1,
            order={
                'expires_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_InvitationLinkUpdateInput,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_InvitationLink record.

        Parameters
        ----------
        data
            LiteLLM_InvitationLink record data specifying what to update
        where
            LiteLLM_InvitationLink filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The updated LiteLLM_InvitationLink record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().update(
            where={
                'id': 'bdcbbieibf',
            },
            data={
                # data to update the LiteLLM_InvitationLink record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_InvitationLinkWhereUniqueInput,
        data: types.LiteLLM_InvitationLinkUpsertInput,
        include: Optional[types.LiteLLM_InvitationLinkInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_InvitationLink filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_InvitationLink model

        Returns
        -------
        prisma.models.LiteLLM_InvitationLink
            The created or updated LiteLLM_InvitationLink record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_invitationlink = await LiteLLM_InvitationLink.prisma().upsert(
            where={
                'id': 'dgjhdcggi',
            },
            data={
                'create': {
                    'id': 'dgjhdcggi',
                    'user_id': 'hfcfhhadh',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'bbihggdcji',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'hgjgibdgd',
                },
                'update': {
                    'user_id': 'hfcfhhadh',
                    'expires_at': datetime.datetime.utcnow(),
                    'created_at': datetime.datetime.utcnow(),
                    'created_by': 'bbihggdcji',
                    'updated_at': datetime.datetime.utcnow(),
                    'updated_by': 'hgjgibdgd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_InvitationLinkUpdateManyMutationInput,
        where: types.LiteLLM_InvitationLinkWhereInput,
    ) -> int:
        """Update multiple LiteLLM_InvitationLink records

        Parameters
        ----------
        data
            LiteLLM_InvitationLink data to update the selected LiteLLM_InvitationLink records to
        where
            Filter to select the LiteLLM_InvitationLink records to update

        Returns
        -------
        int
            The total number of LiteLLM_InvitationLink records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_InvitationLink records
        total = await LiteLLM_InvitationLink.prisma().update_many(
            data={
                'created_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_InvitationLink records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_InvitationLink fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_InvitationLink.prisma().count()

        # results: prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
        results = await LiteLLM_InvitationLink.prisma().count(
            select={
                '_all': True,
                'created_by': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_InvitationLinkCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
    ) -> types.LiteLLM_InvitationLinkCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_InvitationLinkCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None,
        cursor: Optional[types.LiteLLM_InvitationLinkWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_InvitationLinkCountAggregateOutput]:
        """Count the number of LiteLLM_InvitationLink records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_InvitationLink fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_InvitationLink filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_InvitationLink.prisma().count()

        # results: prisma.types.LiteLLM_InvitationLinkCountAggregateOutput
        results = await LiteLLM_InvitationLink.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_InvitationLinkCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_InvitationLinkWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_InvitationLink records.

        Parameters
        ----------
        where
            Optional LiteLLM_InvitationLink filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_InvitationLink records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_InvitationLink records
        total = await LiteLLM_InvitationLink.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_InvitationLinkScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_InvitationLinkWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_InvitationLinkAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_InvitationLinkSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_InvitationLinkMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_InvitationLinkMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_InvitationLinkScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_InvitationLinkCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_InvitationLinkScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_InvitationLinkScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_InvitationLinkGroupByOutput']:
        """Group LiteLLM_InvitationLink records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_InvitationLink fields to group records by
        where
            LiteLLM_InvitationLink filter to select records
        take
            Limit the maximum number of LiteLLM_InvitationLink records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_InvitationLinkGroupByOutput]
            A list of dictionaries representing the LiteLLM_InvitationLink record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_InvitationLink records by updated_by values
        # and count how many records are in each group
        results = await LiteLLM_InvitationLink.prisma().group_by(
            ['updated_by'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LiteLLM_AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LiteLLM_AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LiteLLM_AuditLog.prisma().query_raw(
            'SELECT * FROM LiteLLM_AuditLog WHERE id = $1',
            'bbjbcdfabd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LiteLLM_AuditLog.prisma().query_first(
            'SELECT * FROM LiteLLM_AuditLog WHERE updated_at = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LiteLLM_AuditLogCreateInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new LiteLLM_AuditLog record.

        Parameters
        ----------
        data
            LiteLLM_AuditLog record data
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The created LiteLLM_AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LiteLLM_AuditLog record from just the required fields
        litellm_auditlog = await LiteLLM_AuditLog.prisma().create(
            data={
                # data to create a LiteLLM_AuditLog record
                'action': 'gchfgbcec',
                'table_name': 'bihcjfcjah',
                'object_id': 'bhjdcicaii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LiteLLM_AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LiteLLM_AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LiteLLM_AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LiteLLM_AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a LiteLLM_AuditLog record
                    'action': 'bibedjhcej',
                    'table_name': 'bjcdajabfa',
                    'object_id': 'bchhceeeff',
                },
                {
                    # data to create a LiteLLM_AuditLog record
                    'action': 'bbgaifhdaa',
                    'table_name': 'dgbcdaegb',
                    'object_id': 'beagfbbjig',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LiteLLM_AuditLog record.

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The deleted LiteLLM_AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().delete(
            where={
                'id': 'beicihhijb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LiteLLM_AuditLog record.

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The found LiteLLM_AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_unique(
            where={
                'id': 'fgggcdcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LiteLLM_AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The found LiteLLM_AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'ccjbbjigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
        order: Optional[Union[types.LiteLLM_AuditLogOrderByInput, List[types.LiteLLM_AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LiteLLM_AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LiteLLM_AuditLog records returned
        skip
            Ignore the first N results
        where
            LiteLLM_AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model
        order
            Order the returned LiteLLM_AuditLog records by any field
        distinct
            Filter LiteLLM_AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LiteLLM_AuditLog]
            The list of all LiteLLM_AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LiteLLM_AuditLog records
        litellm_auditlogs = await LiteLLM_AuditLog.prisma().find_many(take=10)

        # find the first 5 LiteLLM_AuditLog records ordered by the changed_by field
        litellm_auditlogs = await LiteLLM_AuditLog.prisma().find_many(
            take=5,
            order={
                'changed_by': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
        order: Optional[Union[types.LiteLLM_AuditLogOrderByInput, List[types.LiteLLM_AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LiteLLM_AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model
        order
            Order the returned LiteLLM_AuditLog records by any field
        distinct
            Filter LiteLLM_AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The first LiteLLM_AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_AuditLog record ordered by the changed_by_api_key field
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_first(
            skip=1,
            order={
                'changed_by_api_key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
        order: Optional[Union[types.LiteLLM_AuditLogOrderByInput, List[types.LiteLLM_AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.LiteLLM_AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LiteLLM_AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model
        order
            Order the returned LiteLLM_AuditLog records by any field
        distinct
            Filter LiteLLM_AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The first LiteLLM_AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LiteLLM_AuditLog record ordered by the action field
        litellm_auditlog = await LiteLLM_AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'action': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LiteLLM_AuditLogUpdateInput,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LiteLLM_AuditLog record.

        Parameters
        ----------
        data
            LiteLLM_AuditLog record data specifying what to update
        where
            LiteLLM_AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The updated LiteLLM_AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().update(
            where={
                'id': 'bhfaabbaha',
            },
            data={
                # data to update the LiteLLM_AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LiteLLM_AuditLogWhereUniqueInput,
        data: types.LiteLLM_AuditLogUpsertInput,
        include: Optional[types.LiteLLM_AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LiteLLM_AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LiteLLM_AuditLog model

        Returns
        -------
        prisma.models.LiteLLM_AuditLog
            The created or updated LiteLLM_AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        litellm_auditlog = await LiteLLM_AuditLog.prisma().upsert(
            where={
                'id': 'ebajedhhf',
            },
            data={
                'create': {
                    'id': 'ebajedhhf',
                    'action': 'bbgaifhdaa',
                    'table_name': 'dgbcdaegb',
                    'object_id': 'beagfbbjig',
                },
                'update': {
                    'action': 'bbgaifhdaa',
                    'table_name': 'dgbcdaegb',
                    'object_id': 'beagfbbjig',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LiteLLM_AuditLogUpdateManyMutationInput,
        where: types.LiteLLM_AuditLogWhereInput,
    ) -> int:
        """Update multiple LiteLLM_AuditLog records

        Parameters
        ----------
        data
            LiteLLM_AuditLog data to update the selected LiteLLM_AuditLog records to
        where
            Filter to select the LiteLLM_AuditLog records to update

        Returns
        -------
        int
            The total number of LiteLLM_AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LiteLLM_AuditLog records
        total = await LiteLLM_AuditLog.prisma().update_many(
            data={
                'table_name': 'jajacedge'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LiteLLM_AuditLog records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_AuditLog.prisma().count()

        # results: prisma.types.LiteLLM_AuditLogCountAggregateOutput
        results = await LiteLLM_AuditLog.prisma().count(
            select={
                '_all': True,
                'object_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LiteLLM_AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
    ) -> types.LiteLLM_AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LiteLLM_AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None,
        cursor: Optional[types.LiteLLM_AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.LiteLLM_AuditLogCountAggregateOutput]:
        """Count the number of LiteLLM_AuditLog records present in the database

        Parameters
        ----------
        select
            Select the LiteLLM_AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LiteLLM_AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LiteLLM_AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LiteLLM_AuditLog.prisma().count()

        # results: prisma.types.LiteLLM_AuditLogCountAggregateOutput
        results = await LiteLLM_AuditLog.prisma().count(
            select={
                '_all': True,
                'before_value': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LiteLLM_AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LiteLLM_AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple LiteLLM_AuditLog records.

        Parameters
        ----------
        where
            Optional LiteLLM_AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LiteLLM_AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LiteLLM_AuditLog records
        total = await LiteLLM_AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LiteLLM_AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.LiteLLM_AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LiteLLM_AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.LiteLLM_AuditLogSumAggregateInput'] = None,
        min: Optional['types.LiteLLM_AuditLogMinAggregateInput'] = None,
        max: Optional['types.LiteLLM_AuditLogMaxAggregateInput'] = None,
        having: Optional['types.LiteLLM_AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LiteLLM_AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LiteLLM_AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LiteLLM_AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LiteLLM_AuditLogGroupByOutput']:
        """Group LiteLLM_AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LiteLLM_AuditLog fields to group records by
        where
            LiteLLM_AuditLog filter to select records
        take
            Limit the maximum number of LiteLLM_AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LiteLLM_AuditLogGroupByOutput]
            A list of dictionaries representing the LiteLLM_AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LiteLLM_AuditLog records by updated_values values
        # and count how many records are in each group
        results = await LiteLLM_AuditLog.prisma().group_by(
            ['updated_values'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models